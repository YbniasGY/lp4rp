\documentclass[a4paper]{article}
\usepackage[hyperref]{xcolor}
\definecolor{darkblue}{rgb}{0, 0, .4}
\usepackage[colorlinks=true,linkcolor=darkblue]{hyperref}
\usepackage{amsmath}
\usepackage[round]{natbib}
\usepackage{noweb}
\noweboptions{english,longxref}
\usepackage{fancyvrb}
\RecustomVerbatimCommand{\VerbatimInput}{VerbatimInput}{frame=lines, fontsize=\footnotesize}
\newcommand{\pkg}[1]{{\fontseries{b}\selectfont #1}}


\begin{document}

\title{R Package Development by Means of \\
  Literate Programming \texttt{(noweb)}}
\author{Bernhard Pfaff}
\date{\today}

\maketitle

\section{Introduction}
\label{S1}

The topic of this article is to elucidate the creation of the R
package \pkg{hiker} by means of literate programming (henceforth:
LP). LP has been introduced by \citet{KNU1984}. Its constituent
characteristic is that the source code of a program as well as the
documentation thereof resides in the same file. To stay in the example
of the \pkg{hiker} package: within the file you are currently reading,
\emph{i.e.}, \texttt{hiker.Rnw}, the whole R source code of the
package as well as an explanation of it, is provided.\footnote{This
  file and the requirements for generating the R package \pkg{hiker}
  are made available on github as
  project \href{https://github.com/bpfaff/lp4rp}{lp4rp}.}
This file can then be processed by the facilities offered in the R package
\pkg{Rnoweb} \citep[see][]{IHA2013}. \pkg{Rnoweb} is a
reimplementation of the \texttt{noweb} software \citep[see][]{RAM1994}
written entirely in R. Creating the whole R package \pkg{hiker} by
mere processing (tangling of the R code) of this file, is however not
entirely true. Given that R packages must meet certain requirements
with respect to the directory structure and the documentation of the
provided functions, methods and classes, some additional tools become
necessary. With respect to setting up the package structure and
saving the produced R source files into the package's sub-directory
\texttt{/R}, a \texttt{Makefile} is employed (the content of this file
is provided in the appendix of this article, see section
\ref{smake}). The generation of the \texttt{man}-pages is accomplished
by utilizing the facilities provided in the \pkg{roxygen2} and
\pkg{devtools} packages \citep[see][respectively]{WIC2015,WIC2016}.\par

What is the package \pkg{hiker}(pronounce as `hike---R') about? Within
\pkg{hiker} the routines for detecting local peaks/troughs of a time
series as proposed by \citet{PAL2009} have been implemented. The
knowledge of these points and the time spans in between these local
maxima/minima can be utilized for analyzing the behavior of predictor
variables in up-/down markets of a financial time series, \emph{e.g.},
a stock price, for instance. Surely, these phases could in principal
be detected by mere eyeball-econometrics, but this approach becomes
burdensome if local peaks/troughs of many time series must be
determined. The package itself is purely written in R and S4-classes
and methods are employed.\par

In the remainder of this article, the proposed algorithms are
presented in the subsequent section. The package structure, the
defined S4-classes with the available methods are discussed in Section
\ref{S3}. In the Appendix of this paper the documentation of the
package in the \texttt{roxygen}-format is provided. This organization
has the advantage that the focus is shifted on the R code snippets
only and is not interspersed with the documentation of the classes and
methods and functions provided by the package.

\section{Detecting Peaks/Troughs}
\label{S2}

\subsection{Notation}
\label{S2SS1}

A uniformly sampled time series $\mathbf{y} = \{y_1, \ldots, y_i,
\ldots, y_T\}$ with $T$ data points is considered. The detection of
peak/trough points is achieved by a function $S(i, y_i, T)$ that
returns for data point $y_i$ a score value.\footnote{It suffices to
  provide a score function for peaks only. Trough points can be
  detected by using the negative values of the series $\mathbf{y}$.}.
If this score value surpasses a user-provided threshold value
$\theta$, \emph{i.e}, $S(i, y_i, T) \ge \theta$ then the point is
considered as a local peak/trough.\par

Furthermore, in case local peak/trough points appear closely together
with respect to time (clustered), then these points can be classified
as a burst or bust, respectively.

\subsection{Algorithms}
\label{S2SS2}

In \citet{PAL2009} five different score functions $S$ have been
suggested. All have in common, that a centered window of size $2*k +
1 $ around $y_i$ is considered. That is, for a positive integer $k$
the $k$ right neighbors $N^+(i,k, T) = \{y_{i+1}, \ldots, y_{i + k}\}$
and the $k$ left neighbors $N^-(i, k, T) = \{\{y_{i-k}, \ldots,
y_{i-1}\}$ are employed for assessing $y\_i$ as a local
peak/trough. The union of $N^-(i, k, T)$ and $N^+(i, k, T)$ is defined
as $N(i, k, T) = N^-(i, k, T) \mathord{\cdot} N^+(i, k, T)$ and if the
center point is included as $N'(i, k, T) = N^-(i, k, T) \mathord{\cdot}
y_i \mathord{\cdot} N^+(i, k, T)$.\par

The first function, $S_1$, computes the score value as the average of
the maximum differences between $y_i$ with its left and right
neighbors. The function is defined as:

\begin{equation}
\label{EQ1}
S_1 =
  \frac{\max{(y_i - y_{i-1}, \ldots, y_i - y_{i-k})} + \max{(y_i -
  y_{i+1}, \ldots, y_i - y_{i+k})}}{2}
\end{equation}

For a span of a time series $\mathbf{y}$ of length $2k + 1$, denoted
by \texttt{x}, the equation~\eqref{EQ1} can be casted in R as:

\nwfilename{hiker.Rnw}\nwbegincode{1}\sublabel{RNWhik1-sco1-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-sco1-1}}}\moddef{score-maxdiff~{\nwtagstyle{}\subpageref{RNWhik1-sco1-1}}}\endmoddef
scmaxdiff <- function(x, k)\{
    cp <- k + 1L
    lmax <- max(x[cp] - head(x, k))
    rmax <- max(x[cp] - tail(x, k))
    (lmax + rmax) / 2.0
\}
\nosublabel{RNWhik1-sco1-1-u4}\nwindexdefn{scmaxdiff}{scmaxdiff}{RNWhik1-sco1-1}\eatline
\nwidentdefs{\\{{scmaxdiff}{scmaxdiff}}}\nwendcode{}\nwbegindocs{2}%def scmaxdiff

Instead of using the maximum differences of $y_i$ with its $k$ left
and right neighbors as in~\eqref{EQ1}, an alternative is to compute
the mean differences and evaluate the average thereof:

\begin{equation}
\label{EQ2}
S_2 = \frac{\frac{(y_i - y_{i-1}, \ldots, y_i - y_{i-k})}{k} +
\frac{(y_i - y_{i+1}, \ldots, y_i - y_{i+k})}{k}}{2}
\end{equation}

This equation can be casted in R as:

\nwenddocs{}\nwbegincode{3}\sublabel{RNWhik1-sco3-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-sco3-1}}}\moddef{score-diffmean~{\nwtagstyle{}\subpageref{RNWhik1-sco3-1}}}\endmoddef
scdiffmean <- function(x, k)\{
    cp <- k + 1L
    ldmean <- x[cp] - mean(head(x, k))
    rdmean <- x[cp] - mean(tail(x, k))
    (ldmean + rdmean) / 2.0
\}
\nwindexdefn{scdiffmean}{scdiffmean}{RNWhik1-sco3-1}\eatline
\nwidentdefs{\\{{scdiffmean}{scdiffmean}}}\nwendcode{}\nwbegindocs{4}%def scdiffmean

Another variation of score computation that has been proposed by
\citet{PAL2009} is to consider the differences to the mean of the $k$
left and right neighbors, that is:

\begin{equation}
\label{EQ3}
S_3 = \frac{
(y_i - \frac{(y_{i-1}, \ldots, y_{i-k})}{k}) +
(y_i - \frac{(y_{i+1}, \ldots, y_{i+k})}{k})}{2}
\end{equation}

The equation~\eqref{EQ3} can be casted as R function \verb?scavgdiff()?
for instance as follows:

\nwenddocs{}\nwbegincode{5}\sublabel{RNWhik1-sco4-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-sco4-1}}}\moddef{score-avgdiff~{\nwtagstyle{}\subpageref{RNWhik1-sco4-1}}}\endmoddef
scavgdiff <- function(x, k)\{
    cp <- k + 1L
    lmean <- mean(x[cp] - head(x, k))
    rmean <- mean(x[cp] - tail(x, k))
    (lmean + rmean) / 2.0
\}
\nwindexdefn{scavgdiff}{scavgdiff}{RNWhik1-sco4-1}\eatline
\nwidentdefs{\\{{scavgdiff}{scavgdiff}}}\nwendcode{}\nwbegindocs{6}%def scavgdiff

The fourth proposed score function differs from the previous three in
the sense that it does take the differences between $y_i$
and its neighbors explicitly into account, but tries to capture its
information content by means of relative entropy. The entropy of a
vector $A$ with elements $A = \{a_1, \ldots, a_m\}$ is given as:

\begin{equation}
H_w(A) = \sum_{i=1}^M \left(-p_w(a_i)\log(p_w(a_i))\right)
\end{equation}

where $p_w(a_i)$ is an estimate of the density value at $a_i$. The
score function is now based on computing the entropies of $H(N((k, i,
T))$ and $H(N'(k, i, T))$. Hereby, the densities can be determined by
means of a kernel density estimator. The score function is then
defined as the difference of the entropies:

\begin{equation}
\label{EQ4}
S_4 = H(N((k, i, T)) - H(N'((k, i, T))
\end{equation}

This concept is implemented in the function \verb?scentropy()?. The
empirical density is computed by calling \verb?density()?. The ellipsis
argument of \verb?scentropy()? is passed down to this function and hereby
allowing the user to employ other than the default arguments of
\verb?density()?.

\nwenddocs{}\nwbegincode{7}\sublabel{RNWhik1-sco5-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-sco5-1}}}\moddef{score-entropy~{\nwtagstyle{}\subpageref{RNWhik1-sco5-1}}}\endmoddef
scentropy <- function(x, k, ...)\{
    cp <- k + 1L
    dfull <- density(x, ...)$y
    hfull <- sum(-dfull * log(dfull))
    dexct <- density(x[-cp], ...)$y
    hexct <- sum(-dexct * log(dexct))
    hfull - hexct
\}
\nwindexdefn{scentropy}{scentropy}{RNWhik1-sco5-1}\eatline
\nwidentdefs{\\{{scentropy}{scentropy}}}\nwendcode{}\nwbegindocs{8}%def scentropy

Finally, a moment-based score function has been put forward in the
article by Palshikar. Hereby, the first and second moment of $N((k, i,
T))$ are computed and a t-type statistic can be computed as $(y_i - m)
/ s$. If this statistic surpasses a provided threshold $h$, then the
data point is considered as a local peak/trough.

\begin{equation}
\label{EQ5}
S_5 =
\begin{cases}
1 & (y_i - m) / s \ge h \\
0 & \text{else}
\end{cases}
\end{equation}

This type of scoring algorithm is implemented as function
\verb?scttype()? below:

\nwenddocs{}\nwbegincode{9}\sublabel{RNWhik1-sco6-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-sco6-1}}}\moddef{score-ttype~{\nwtagstyle{}\subpageref{RNWhik1-sco6-1}}}\endmoddef
scttype <- function(x, k, tval)\{
    cp <- k + 1L
    m <- mean(x[-cp])
    s <- sd(x[-cp])
    tstat <- (x[cp] - m) / s
    if ( abs(tstat) < tval )\{
        tstat <- 0
    \}
    tstat
\}
\nwindexdefn{scttype}{scttype}{RNWhik1-sco6-1}\eatline
\nwidentdefs{\\{{scttype}{scttype}}}\nwendcode{}\nwbegindocs{10}%def scttype

Incidentally, an ensemble forecast of these five algorithms can be
utilized for local peak/trough classification. Hereby, one could
either use a hybrid approach, whereby only those data points are
considered as peak/trough points, if all five methods coincide. This
concept is casted in the function \verb?schybrid()?. Hereby, the signs of
all five scoring algorithm are tested for equality.

\nwenddocs{}\nwbegincode{11}\sublabel{RNWhik1-sco7-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-sco7-1}}}\moddef{score-hybrid~{\nwtagstyle{}\subpageref{RNWhik1-sco7-1}}}\endmoddef
schybrid <- function(x, k, tval, ...)\{
    s <- c(sign(scmaxdiff(x, k)),
           sign(scavgdiff(x, k)),
           sign(scdiffmean(x, k)),
           sign(scentropy(x, k, ...)),
           sign(scttype(x, k, tval)))
    val <- unique(s)
    if ( length(val) < 2 )\{
        return(s[1])
    \} else \{
        return(0)
    \}
\}
\nwindexdefn{schybrid}{schybrid}{RNWhik1-sco7-1}\eatline
\nwidentdefs{\\{{schybrid}{schybrid}}}\nwidentuses{\\{{scavgdiff}{scavgdiff}}\\{{scdiffmean}{scdiffmean}}\\{{scentropy}{scentropy}}\\{{scmaxdiff}{scmaxdiff}}\\{{scttype}{scttype}}}\nwindexuse{scavgdiff}{scavgdiff}{RNWhik1-sco7-1}\nwindexuse{scdiffmean}{scdiffmean}{RNWhik1-sco7-1}\nwindexuse{scentropy}{scentropy}{RNWhik1-sco7-1}\nwindexuse{scmaxdiff}{scmaxdiff}{RNWhik1-sco7-1}\nwindexuse{scttype}{scttype}{RNWhik1-sco7-1}\nwendcode{}\nwbegindocs{12}%def schybrid

It is also conceivable to base the classification on a majority
vote. For instance, if three out of the five algorithm classify a data
point as a local peak/trough, then this is taken as sufficient
evidence. This approach is defined in the function \verb?scvote()? below.
The count of same `votes' is set by the argument \texttt{confby}. Its
default value is $3$, \emph{i.e.}, a simple majority. For
\texttt{confby = 5} the function would return the same classification
as \verb?schybrid()? does.

\nwenddocs{}\nwbegincode{13}\sublabel{RNWhik1-sco8-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-sco8-1}}}\moddef{score-vote~{\nwtagstyle{}\subpageref{RNWhik1-sco8-1}}}\endmoddef
scvote <- function(x, k, tval, confby = 3, ...)\{
    s <- c(sign(scmaxdiff(x, k)),
           sign(scavgdiff(x, k)),
           sign(scdiffmean(x, k)),
           sign(scentropy(x, k, ...)),
           sign(scttype(x, k, tval)))
    pos <- rep(1, 5)
    zer <- rep(0, 5)
    neg <- rep(-1, 5)
    spos <- sum(s == pos)
    szer <- sum(s == zer)
    sneg <- sum(s == neg)
    v <- c(spos, szer, sneg)
    idx <- which(v >= confby)
    vals <- c(1, 0, -1)
    if ( length(idx) > 0 )\{
        return(vals[idx])
    \} else \{
        return(0)
    \}
\}
\nwindexdefn{scvote}{scvote}{RNWhik1-sco8-1}\eatline
\nwidentdefs{\\{{scvote}{scvote}}}\nwidentuses{\\{{scavgdiff}{scavgdiff}}\\{{scdiffmean}{scdiffmean}}\\{{scentropy}{scentropy}}\\{{scmaxdiff}{scmaxdiff}}\\{{scttype}{scttype}}}\nwindexuse{scavgdiff}{scavgdiff}{RNWhik1-sco8-1}\nwindexuse{scdiffmean}{scdiffmean}{RNWhik1-sco8-1}\nwindexuse{scentropy}{scentropy}{RNWhik1-sco8-1}\nwindexuse{scmaxdiff}{scmaxdiff}{RNWhik1-sco8-1}\nwindexuse{scttype}{scttype}{RNWhik1-sco8-1}\nwendcode{}\nwbegindocs{14}%def scvote

\subsection{Combining score methods}
\label{S2SS3}

What has been accomplished so far, are the function definitions of the
five proposed heuristics and combinations thereof with respect to a
sub-sample a time series of length $2k + 1$. These functions are
now combined into a single \verb?score()? function as shown in the
subsequent R code chunk. The selection of the kind of score
computation is conducted by calling the \verb?switch()? function.

\nwenddocs{}\nwbegincode{15}\sublabel{RNWhik1-sco9-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-sco9-1}}}\moddef{score-wrapper~{\nwtagstyle{}\subpageref{RNWhik1-sco9-1}}}\endmoddef
score <- function(x, k,
                  scoreby = c("vote", "avg", "diff", "max", "ent",
                              "ttype", "hybrid"),
                  tval = 1.0, confby = 3, ...)\{
    scoreby <- match.arg(scoreby)
    ans <- switch(scoreby,
                  vote = scvote(x, k, tval, confby, ...),
                  avg = scavgdiff(x, k),
                  diff = scdiffmean(x, k),
                  max = scmaxdiff(x, k),
                  ent = scentropy(x, k, ...),
                  ttype = scttype(x, k, tval),
                  hybrid = schybrid(x, k, tval, ...)
                  )
    ans
\}
\nwindexdefn{score}{score}{RNWhik1-sco9-1}\eatline
\nwidentdefs{\\{{score}{score}}}\nwidentuses{\\{{scavgdiff}{scavgdiff}}\\{{scdiffmean}{scdiffmean}}\\{{scentropy}{scentropy}}\\{{schybrid}{schybrid}}\\{{scmaxdiff}{scmaxdiff}}\\{{scttype}{scttype}}\\{{scvote}{scvote}}}\nwindexuse{scavgdiff}{scavgdiff}{RNWhik1-sco9-1}\nwindexuse{scdiffmean}{scdiffmean}{RNWhik1-sco9-1}\nwindexuse{scentropy}{scentropy}{RNWhik1-sco9-1}\nwindexuse{schybrid}{schybrid}{RNWhik1-sco9-1}\nwindexuse{scmaxdiff}{scmaxdiff}{RNWhik1-sco9-1}\nwindexuse{scttype}{scttype}{RNWhik1-sco9-1}\nwindexuse{scvote}{scvote}{RNWhik1-sco9-1}\nwendcode{}\nwbegindocs{16}%def score

The functions for computing scores are grouped together in the R file
\verb?score.R? as shown in the next chunk. The function definitions are
interspersed with the roxygen tags, which will be parsed to the
\verb?Rd?-file \verb?score.Rd?. Incidentally, only code chunk with names
ending in \verb?.R? are treated as files that should be tangled and saved
under the given code chunk's name.

\nwenddocs{}\nwbegincode{17}\sublabel{RNWhik1-sco10-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-sco10-1}}}\moddef{score.R~{\nwtagstyle{}\subpageref{RNWhik1-sco10-1}}}\endmoddef\let\nwnotused=\nwoutput{}
\LA{}man-func-score~{\nwtagstyle{}\subpageref{RNWhik1-man34-1}}\RA{}
\LA{}score-wrapper~{\nwtagstyle{}\subpageref{RNWhik1-sco9-1}}\RA{}
#' @rdname score
\LA{}score-maxdiff~{\nwtagstyle{}\subpageref{RNWhik1-sco1-1}}\RA{}
#' @rdname score
\LA{}score-diffmean~{\nwtagstyle{}\subpageref{RNWhik1-sco3-1}}\RA{}
#' @rdname score
\LA{}score-avgdiff~{\nwtagstyle{}\subpageref{RNWhik1-sco4-1}}\RA{}
#' @rdname score
\LA{}score-entropy~{\nwtagstyle{}\subpageref{RNWhik1-sco5-1}}\RA{}
#' @rdname score
\LA{}score-ttype~{\nwtagstyle{}\subpageref{RNWhik1-sco6-1}}\RA{}
#' @rdname score
\LA{}score-hybrid~{\nwtagstyle{}\subpageref{RNWhik1-sco7-1}}\RA{}
#' @rdname score
\LA{}score-vote~{\nwtagstyle{}\subpageref{RNWhik1-sco8-1}}\RA{}
\nwnotused{score.R}\nwendcode{}\nwbegindocs{18}@

So far the wrapper function \verb?score()? has been created, by which a single
point is assessed for being a local maximum or minimum. For analyzing
a whole time series for its local extrema, this routine can then be applied
to each data point and its left/right neighbors. This task is
accomplished with the function \verb?hiker()? as defined next.

\nwenddocs{}\nwbegincode{19}\sublabel{RNWhik1-hik11-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-hik11-1}}}\moddef{hiker-func~{\nwtagstyle{}\subpageref{RNWhik1-hik11-1}}}\endmoddef
hiker <- function(y, k,
                  scoreby = c("vote", "avg", "diff", "max", "ent",
                              "ttype", "hybrid"),
                  tval = 1.0, confby = 3, ...)\{
\LA{}hiker-check~{\nwtagstyle{}\subpageref{RNWhik1-hik12-1}}\RA{}
    ## rolling centered window for peak scores
    s <- rollapply(y, width = ms, FUN = score,
                   k = k, scoreby = scoreby, tval = tval, ...)
\LA{}hiker-output~{\nwtagstyle{}\subpageref{RNWhik1-hik13-1}}\RA{}
\}
\nwidentuses{\\{{score}{score}}}\nwindexuse{score}{score}{RNWhik1-hik11-1}\nwendcode{}\nwbegindocs{20}@

The arguments of the function are \verb?y? for the time series object,
\verb?k? for the count of left/right neighbors, and \verb?scoreby? for the
selection of the scoring method. The arguments \verb?tval? and \verb?confby?
belong the scoring concepts `ttype' and `hybrid', respectively, and
the ellipsis argument is passed down to the call of \verb?scentropy()?
for \verb?scoreby = 'ent'?.\par

The function body consists of three parts. First, the provided
arguments are checked for their validity (as shown in the following
code chunk). The computation of the scores is accomplished with the
\verb?rollapply()? function of the package \pkg{zoo}
\citep[see][]{ZEI2005}. Finally, the returned object is created.\par

\nwenddocs{}\nwbegincode{21}\sublabel{RNWhik1-hik12-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-hik12-1}}}\moddef{hiker-check~{\nwtagstyle{}\subpageref{RNWhik1-hik12-1}}}\endmoddef
    y <- as.zoo(y)
    ## checking arguments
    k <- as.integer(abs(k))
    ms <- 2 * k + 1L
    if ( is.null(dim(y)) )\{
        yname <- "series"
        n <- length(y)
        if ( n < ms ) \{
            stop(paste("Sample size of 'y' is ", n,
                       " and k = ", k, ".\\n", sep = ""))
            \}
    \} else \{
        n <- nrow(y)
        yname <- colnames(y)[1]
        if ( n < ms ) \{
            stop(paste("Sample size of 'y' is ", n,
                       " and k = ", k, ".\\n", sep = ""))
        \}
        if ( ncol(y) > 1 ) \{
            stop("Provide univariate time series of S3-class 'zoo'.\\n")
        \}
    \}
    if ( (confby < 3) || (confby > 5) )\{
        stop("\\nArgument 'confby' must be integer and in set \{3, 4, 5\}.\\n")
    \}
    scoreby <- match.arg(scoreby)
\nwendcode{}\nwbegindocs{22}@

Within the check section of the function body, the object \verb?y? is
first coerced to a \verb?zoo? object and the count of neighbors is
coerced to a positive integer. Next, the size of the sub-sample for
computing the scores is assigned to the object \verb?ms?. The remaining
part consists of checks whether the series is univariate and its
length is at least $2 \times k + 1$. Finally, the scoring method is
determined from the argument \verb?scoreby? by means of the \verb?match.arg()?
function.\par

In the final part of the function body of \verb?hiker()?, the returned
object is created as depicted in the subsequent R code chunk.

\nwenddocs{}\nwbegincode{23}\sublabel{RNWhik1-hik13-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-hik13-1}}}\moddef{hiker-output~{\nwtagstyle{}\subpageref{RNWhik1-hik13-1}}}\endmoddef
    ## merging time series and scores
    ans <- merge(y, s)
    colnames(ans) <- c("Series", "Scores")
    des <- switch(scoreby,
                  vote = "majority vote",
                  avg = "average of averaged differences",
                  diff = "average of mean differences",
                  max = "average of maximum differences",
                  ent = "difference of entropies",
                  ttype = "t-type statistic",
                  hybrid = "hybrid")
    new("HikeR", ys = ans, k = k, scoreby = des, yname = yname)
\nwendcode{}\nwbegindocs{24}@

First, the time series object \verb?y? is merged with the series of the
computed scores and assigned to \verb?ans?. Next the type of scoring
method is stored as character string to \verb?des?. Finally, an object of
S4-class \verb?HikeR? is created and returned. The definition of this
formal class is provided in section~\ref{S3SS2}.\par

Given that \verb?hiker()? is the core function of the package, it will be
stored in its own \verb?hiker.R? file, as commanded by the next chunk.

\nwenddocs{}\nwbegincode{25}\sublabel{RNWhik1-hik14-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-hik14-1}}}\moddef{hiker.R~{\nwtagstyle{}\subpageref{RNWhik1-hik14-1}}}\endmoddef\let\nwnotused=\nwoutput{}
\LA{}man-func-hiker~{\nwtagstyle{}\subpageref{RNWhik1-man35-1}}\RA{}
\LA{}hiker-func~{\nwtagstyle{}\subpageref{RNWhik1-hik11-1}}\RA{}
\nwnotused{hiker.R}\nwendcode{}\nwbegindocs{26}@

\section{Package structure}
\label{S3}

\subsection{Preliminaries}
\label{S3SS1}

R packages must contain a \verb?DESCRIPTION? and a \verb?NAMESPACE?
file. Both reside in the package's root directory. As mentioned
earlier, only chunks with names ending in `\verb?.R?' are saved to disk
by the tangling function of \pkg{Rnoweb}. Therefore, the content
of the description file is first, casted in the \verb?DESCRIPTION.R?
file as shown below and is then moved by a directive in the
\verb?Makefile? to the root directory of the package \pkg{hiker} without
the file's suffix.

\nwenddocs{}\nwbegincode{27}\sublabel{RNWhik1-DES15-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-DES15-1}}}\moddef{DESCRIPTION.R~{\nwtagstyle{}\subpageref{RNWhik1-DES15-1}}}\endmoddef\let\nwnotused=\nwoutput{}
Package: hiker
Title: Local Peak and Trough of a Time Series
Version: 0.0.0.9000
Authors@R: person("Bernhard", "Pfaff", email = "bernhard@pfaffikus.de",
                  role = c("aut", "cre"))
Description: Methods for detecting local peaks and troughs of a time series.
Depends: R (>= 3.3.1), zoo, methods
License: GPL-3
Encoding: UTF-8
LazyData: true
\nwnotused{DESCRIPTION.R}\nwendcode{}\nwbegindocs{28}@

With respect to the creation of the \verb?NAMESPACE? file, matters are a
bit different. The import/export directives contained in this file can
be written as \verb?roxygen? tags and the assembly of the tags and the
saving of the file under the package's root directory is conducted by
the \verb?document()? function of \pkg{devtools}. Hence, it suffices to
include the tags in a named chunk with suffix `\verb?.R?'. In the case
\pkg{hiker} the import directives are included in the R-file
\verb?Allclasses.R?. As is indicated by the file name, the definitions of
the S4-classes will also reside in this file. The skeleton of this
this file is provided in the subsequent chunk.

\nwenddocs{}\nwbegincode{29}\sublabel{RNWhik1-All16-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-All16-1}}}\moddef{Allclasses.R~{\nwtagstyle{}\subpageref{RNWhik1-All16-1}}}\endmoddef\let\nwnotused=\nwoutput{}
\LA{}NAMESPACE~{\nwtagstyle{}\subpageref{RNWhik1-NAM17-1}}\RA{}
\LA{}HikerClass~{\nwtagstyle{}\subpageref{RNWhik1-Hik18-1}}\RA{}
\LA{}PtbbClass~{\nwtagstyle{}\subpageref{RNWhik1-Ptb19-1}}\RA{}
\nwnotused{Allclasses.R}\nwendcode{}\nwbegindocs{30}@

The import directives for the required packages and functions are then
given as:

\nwenddocs{}\nwbegincode{31}\sublabel{RNWhik1-NAM17-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-NAM17-1}}}\moddef{NAMESPACE~{\nwtagstyle{}\subpageref{RNWhik1-NAM17-1}}}\endmoddef
#' @import methods
NULL
#' @import zoo
NULL
#' @importFrom graphics plot
NULL
#' @importFrom stats density sd na.omit start end smooth
NULL
#' @importFrom utils head tail
NULL

# Setting old (aka S3) classes
setOldClass("zoo")
\nwendcode{}\nwbegindocs{32}@

\subsection{S4-classes and generics}
\label{S3SS2}

Two S4-classes are defined. The first, \verb?HikeR?, has been
mentioned briefly in the discussion of the core function
\verb?hiker()?. The class consists of four slots, as shown in the
subsequent code chunk. Objects of the slot \verb?ys? are of class \verb?zoo?
and contain the time series and the score value. The slot \verb?k? is of
type \verb?integer? and holds the count of left/right neighbors. The
character slot \verb?scoreby? provides a literal description of the
employed scoring algorithm and the slot \verb?yname? is a character
string of the time series name.

\nwenddocs{}\nwbegincode{33}\sublabel{RNWhik1-Hik18-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-Hik18-1}}}\moddef{HikerClass~{\nwtagstyle{}\subpageref{RNWhik1-Hik18-1}}}\endmoddef
\LA{}man-class-HikeR~{\nwtagstyle{}\subpageref{RNWhik1-man36-1}}\RA{}
setClass("HikeR", slots = list(ys = "zoo",
                               k = "integer",
                               scoreby = "character",
                               yname = "character"))
\nwendcode{}\nwbegindocs{34}@

The \verb?HikeR?-class does not contain explicitly the information
whether a certain data point is classified as a peak or trough, or
does belong to a certain phase of the time series progression. This
lack of explicit information is filled by the S4-class \verb?PTBB?; it is
a short-hand for
`\underline{P}eaks\underline{T}roughs\underline{B}urst\underline{B}ust'. Its
slot \verb?pt? is of informal class \verb?zoo? and is a logical whether a
data point does belong to one the above mentioned points/phases. The
slot \verb?type? is a literal description thereof and the employed
threshold value for making this classification is available in the
slot \verb?h?. The class definition is provided in the subsequent code
chunk.

\nwenddocs{}\nwbegincode{35}\sublabel{RNWhik1-Ptb19-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-Ptb19-1}}}\moddef{PtbbClass~{\nwtagstyle{}\subpageref{RNWhik1-Ptb19-1}}}\endmoddef
\LA{}man-class-PTBB~{\nwtagstyle{}\subpageref{RNWhik1-man37-1}}\RA{}
setClass("PTBB", slots = list(pt = "zoo",
                              type = "character",
                              h = "numeric"))
\nwendcode{}\nwbegindocs{36}@

Next, the following generic functions are defined in the file
\verb?Allgenerics.R?. The methods of these generics are discussed in the
section \ref{S3SS3}.

\nwenddocs{}\nwbegincode{37}\sublabel{RNWhik1-All20-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-All20-1}}}\moddef{Allgenerics.R~{\nwtagstyle{}\subpageref{RNWhik1-All20-1}}}\endmoddef\let\nwnotused=\nwoutput{}
# generic for extracting peaks
setGeneric("peaks", function(object, ...) standardGeneric("peaks"))
# generic for extracting troughs
setGeneric("troughs", function(object, ...) standardGeneric("troughs"))
# generic for extracting bursts
setGeneric("bursts", function(object, ...) standardGeneric("bursts"))
# generic for extracting busts
setGeneric("busts", function(object, ...) standardGeneric("busts"))
# generic for computing ridges
setGeneric("ridges", function(object, ...) standardGeneric("ridges"))
# generic for computing phases
setGeneric("phases", function(object, ...) standardGeneric("phases"))
# generic for extracting topeaks
setGeneric("topeaks", function(object, ...) standardGeneric("topeaks"))
# generic for extracting totroughs
setGeneric("totroughs", function(object, ...) standardGeneric("totroughs"))
# generic for computing runs
setGeneric("runs", function(x) standardGeneric("runs"))
\nwnotused{Allgenerics.R}\nwendcode{}\nwbegindocs{38}@

\subsection{Methods for S4-class 'HikeR'}
\label{S3SS3}

In this section the S4-methods for objects of class \verb?HikeR? are
discussed. The provided methods are for showing \verb?show()?,
summarizing \verb?summary()?, retrieval of peaks \verb?peaks()? and troughs
\verb?troughs()? for this type of objects. Furthermore, the concept of
bursts phases (close occurrence of peaks with respect to time) and
busts (close occurrence of troughs with respect to time) are defined
as methods \verb?bursts()? and \verb?busts()?, respectively. Additional
methods for characterising the progression of a time series, such as
`ridges', `phases', `to-peaks' and `to-troughs' are provided,
too. Finally, a \verb?plot()?-method is available whereby the user can
hightlight/shade the local optima and the phases in between them. All
of these methods are contained in the file \verb?hiker-methods.R?. The
skeleton of this file is provided next.

\nwenddocs{}\nwbegincode{39}\sublabel{RNWhik1-Hik21-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-Hik21-1}}}\moddef{HikerMethods.R~{\nwtagstyle{}\subpageref{RNWhik1-Hik21-1}}}\endmoddef\let\nwnotused=\nwoutput{}
\LA{}HikeR-show~{\nwtagstyle{}\subpageref{RNWhik1-Hik22-1}}\RA{}
\LA{}HikeR-summary~{\nwtagstyle{}\subpageref{RNWhik1-Hik23-1}}\RA{}
\LA{}HikeR-peaks~{\nwtagstyle{}\subpageref{RNWhik1-Hik24-1}}\RA{}
\LA{}HikeR-troughs~{\nwtagstyle{}\subpageref{RNWhik1-Hik25-1}}\RA{}
\LA{}HikeR-bursts~{\nwtagstyle{}\subpageref{RNWhik1-Hik26-1}}\RA{}
\LA{}HikeR-busts~{\nwtagstyle{}\subpageref{RNWhik1-Hik27-1}}\RA{}
\LA{}HikeR-ridges~{\nwtagstyle{}\subpageref{RNWhik1-Hik28-1}}\RA{}
\LA{}HikeR-phases~{\nwtagstyle{}\subpageref{RNWhik1-Hik29-1}}\RA{}
\LA{}HikeR-topeaks~{\nwtagstyle{}\subpageref{RNWhik1-Hik30-1}}\RA{}
\LA{}HikeR-totroughs~{\nwtagstyle{}\subpageref{RNWhik1-Hik31-1}}\RA{}
\LA{}HikeR-plot~{\nwtagstyle{}\subpageref{RNWhik1-Hik32-1}}\RA{}
\nwnotused{HikerMethods.R}\nwendcode{}\nwbegindocs{40}@

\subsubsection{\texttt{show}-method}
The \verb?show?-method provides a brief overview of
\verb?HikeR?-objects. Its definition is given in the following chunk. The
\verb?roxygen? documentation is deferred to the chunk labeled
\verb?man-HikeR-show? and provided in the appendix \ref{S4SS3}.

\nwenddocs{}\nwbegincode{41}\sublabel{RNWhik1-Hik22-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-Hik22-1}}}\moddef{HikeR-show~{\nwtagstyle{}\subpageref{RNWhik1-Hik22-1}}}\endmoddef
\LA{}man-HikeR-show~{\nwtagstyle{}\subpageref{RNWhik1-man38-1}}\RA{}
setMethod("show",
          signature(object = "HikeR"), function(object)\{
              cat(paste("Peak/trough score computed as: ",
                        object@scoreby, ".\\n", sep = ""))
              cat(paste("Count of left/right neighbours: ", object@k,
                        ".\\n", sep = ""))
              cat("\\nSummary statistics of scores:\\n")
              print(summary(object))
          \}
)
\nwendcode{}\nwbegindocs{42}@

First, the employed scoring-method and the count of left/right
neighbors is printed \emph{via} the \verb?cat()? and \verb?paste()?
functions. Second, the \verb?summary?-method is called, which provides
descriptive statistics of the scores and is formally defined in the
next section.

\subsubsection{\texttt{summary}-method}
The \verb?summary?-method for numerics is applied to the second column of the
slot \verb?ys?, \emph{i.e.}, the computed score values. These numbers are
extracted from the \verb?zoo? object by utilizing the \verb?coredata()?
function. Akin, to the \verb?show?-method, the within-package documentation
is deferred to the appendix.

\nwenddocs{}\nwbegincode{43}\sublabel{RNWhik1-Hik23-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-Hik23-1}}}\moddef{HikeR-summary~{\nwtagstyle{}\subpageref{RNWhik1-Hik23-1}}}\endmoddef
\LA{}man-HikeR-summary~{\nwtagstyle{}\subpageref{RNWhik1-man39-1}}\RA{}
setMethod("summary",
          signature(object = "HikeR"),
          function (object, ...)\{
              summary(na.omit(coredata(object@ys[, 2])))
          \}
)
\nwendcode{}\nwbegindocs{44}@

\subsubsection{\texttt{peaks}-method}

\nwenddocs{}\nwbegincode{45}\sublabel{RNWhik1-Hik24-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-Hik24-1}}}\moddef{HikeR-peaks~{\nwtagstyle{}\subpageref{RNWhik1-Hik24-1}}}\endmoddef
\LA{}man-HikeR-peaks~{\nwtagstyle{}\subpageref{RNWhik1-man40-1}}\RA{}
setMethod("peaks",
    signature(object = "HikeR"),
    function (object, h = 0) \{
        ans <- object@ys[, 2] > h
        new("PTBB", pt = ans, type = "peak", h = h)
    \}
)
\nwendcode{}\nwbegindocs{46}@

\subsubsection{\texttt{troughs}-method}

\nwenddocs{}\nwbegincode{47}\sublabel{RNWhik1-Hik25-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-Hik25-1}}}\moddef{HikeR-troughs~{\nwtagstyle{}\subpageref{RNWhik1-Hik25-1}}}\endmoddef
\LA{}man-HikeR-troughs~{\nwtagstyle{}\subpageref{RNWhik1-man41-1}}\RA{}
setMethod("troughs",
    signature(object = "HikeR"),
    function (object, h = 0) \{
        ans <- object@ys[, 2] < -h
        new("PTBB", pt = ans, type = "trough", h = h)
    \}
)
\nwendcode{}\nwbegindocs{48}@

\subsubsection{\texttt{bursts}-method}

\nwenddocs{}\nwbegincode{49}\sublabel{RNWhik1-Hik26-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-Hik26-1}}}\moddef{HikeR-bursts~{\nwtagstyle{}\subpageref{RNWhik1-Hik26-1}}}\endmoddef
\LA{}man-HikeR-bursts~{\nwtagstyle{}\subpageref{RNWhik1-man42-1}}\RA{}
setMethod("bursts",
    signature(object = "HikeR"),
    function (object, h = 0, b = object@k) \{
        lpts <- object@ys[, 2] > h
        lidx <- which(lpts == TRUE)
        nidx <- length(lidx)
        if ( nidx > 1 )\{
            for ( i in 2:nidx )\{
                didx <- lidx[i] - lidx[i - 1]
                if ( didx <= b )\{
                    lpts[(lidx[i]):(lidx[i - 1])] <- TRUE
                \}
            \}
        \}
        ans <- zoo(lpts, order.by = index(object@ys))
        new("PTBB", pt = ans, type = "burst", h = h)
\})
\nwendcode{}\nwbegindocs{50}@

\subsubsection{\texttt{busts}-method}

\nwenddocs{}\nwbegincode{51}\sublabel{RNWhik1-Hik27-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-Hik27-1}}}\moddef{HikeR-busts~{\nwtagstyle{}\subpageref{RNWhik1-Hik27-1}}}\endmoddef
\LA{}man-HikeR-busts~{\nwtagstyle{}\subpageref{RNWhik1-man43-1}}\RA{}
setMethod("busts",
    signature(object = "HikeR"),
    function (object, h = 0, b = object@k) \{
        lpts <- object@ys[, 2] < h
        lidx <- which(lpts == TRUE)
        nidx <- length(lidx)
        if ( nidx > 1 )\{
            for ( i in 2:nidx )\{
                didx <- lidx[i] - lidx[i - 1]
                if ( didx <= b )\{
                    lpts[(lidx[i]):(lidx[i - 1])] <- TRUE
                \}
            \}
        \}
        ans <- zoo(lpts, order.by = index(object@ys))
        new("PTBB", pt = ans, type = "bust", h = h)
\})
\nwendcode{}\nwbegindocs{52}@

\subsubsection{\texttt{ridges}-method}

\nwenddocs{}\nwbegincode{53}\sublabel{RNWhik1-Hik28-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-Hik28-1}}}\moddef{HikeR-ridges~{\nwtagstyle{}\subpageref{RNWhik1-Hik28-1}}}\endmoddef
\LA{}man-HikeR-ridges~{\nwtagstyle{}\subpageref{RNWhik1-man44-1}}\RA{}
setMethod("ridges",
    signature(object = "HikeR"),
    function (object, h = 0, b = object@k) \{
        N <- nrow(object@ys)
        k <- object@k
        bustp <- busts(object, h = h, b = b)@pt
        burstp <- bursts(object, h = h, b = b)@pt
        bbp <- cbind(bustp, burstp)
        ans <- zoo(FALSE, order.by = index(bustp))
        ridx <- which ( (rowSums(bbp) > 1) | (rowSums(bbp) < 1) )
        ans[ridx] <- TRUE
        ans[1:object@k] <- NA
        ans[(N - k + 1):N] <- NA
        new("PTBB", pt = ans, type = "ridge", h = h)
\})
\nwendcode{}\nwbegindocs{54}@

\subsubsection{\texttt{phases}-method}

\nwenddocs{}\nwbegincode{55}\sublabel{RNWhik1-Hik29-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-Hik29-1}}}\moddef{HikeR-phases~{\nwtagstyle{}\subpageref{RNWhik1-Hik29-1}}}\endmoddef
\LA{}man-HikeR-phases~{\nwtagstyle{}\subpageref{RNWhik1-man45-1}}\RA{}
setMethod("phases",
    signature(object = "HikeR"),
    function (object, h = 0, b = object@k) \{
        N <- nrow(object@ys)
        ans <- rep(NA, N)
        bustp <- busts(object, h = h, b = b)@pt
        ans[which(bustp == TRUE)] <- "bust"
        burstp <- bursts(object, h = h, b = b)@pt
        burstp
        ans[which(burstp == TRUE)] <- "burst"
        ridgep <- ridges(object, h = h, b = b)@pt
        ans[which(ridgep == TRUE)] <- "ridge"
        ans <- factor(ans)
        ans <- zoo(ans, order.by = index(object@ys))
        new("PTBB", pt = ans, type = "phase", h = h)
\})
\nwendcode{}\nwbegindocs{56}@

\subsubsection{\texttt{topeaks}-method}

\nwenddocs{}\nwbegincode{57}\sublabel{RNWhik1-Hik30-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-Hik30-1}}}\moddef{HikeR-topeaks~{\nwtagstyle{}\subpageref{RNWhik1-Hik30-1}}}\endmoddef
\LA{}man-HikeR-topeaks~{\nwtagstyle{}\subpageref{RNWhik1-man46-1}}\RA{}
setMethod("topeaks",
    signature(object = "HikeR"),
    function (object, h = 0) \{
        N <- nrow(object@ys)
        k <- object@k
        ans <- zoo(rep(TRUE, N), order.by = index(object@ys))
        ans[1:k] <- NA
        ans[(N - k + 1):N] <- NA
        peakp <- peaks(object, h)@pt
        pidx <- which(peakp == TRUE)
        npidx <- length(pidx)
        troup <- troughs(object, h)@pt
        tidx <- which(troup == TRUE)
        ntidx <- length(tidx)
        if ( npidx == 0 )\{
            warning("\\nNo local peak points.\\n")
            return(NULL)
        \}
        if ( ntidx == 0 )\{
            warning("\\nNo local trough points.\\n")
            return(NULL)
        \}
        ## if trough comes first, set prior points to FALSE
        if ( tidx[1] < pidx[1] )\{
            ans[(k + 1):tidx[1]] <- FALSE
        \}
        for ( i in 1:ntidx ) \{
            previouspeaks <- which(pidx < tidx[i])
            countpreviouspeaks <- length(previouspeaks)
            if ( countpreviouspeaks > 0 )\{
                maxpos <- which.max(object@ys[pidx[previouspeaks], 1])
                ans[(pidx[maxpos] + 1):tidx[i]] <- FALSE
                pidx <- pidx[-c(1:countpreviouspeaks)]
            \}
        \}
        new("PTBB", pt = ans, type = "topeak", h = h)
\})
\nwendcode{}\nwbegindocs{58}@

\subsubsection{\texttt{totroughs}-method}

\nwenddocs{}\nwbegincode{59}\sublabel{RNWhik1-Hik31-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-Hik31-1}}}\moddef{HikeR-totroughs~{\nwtagstyle{}\subpageref{RNWhik1-Hik31-1}}}\endmoddef
\LA{}man-HikeR-totroughs~{\nwtagstyle{}\subpageref{RNWhik1-man47-1}}\RA{}
setMethod("totroughs",
    signature(object = "HikeR"),
    function (object, h = 0) \{
        ans <- topeaks(object, h)
        ans@pt <- !ans@pt
        ans@type <- "tottrough"
        ans
\})
\nwendcode{}\nwbegindocs{60}@

\subsubsection{\texttt{plot}-method}

\nwenddocs{}\nwbegincode{61}\sublabel{RNWhik1-Hik32-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-Hik32-1}}}\moddef{HikeR-plot~{\nwtagstyle{}\subpageref{RNWhik1-Hik32-1}}}\endmoddef
\LA{}man-HikeR-plot~{\nwtagstyle{}\subpageref{RNWhik1-man48-1}}\RA{}
setMethod("plot",
    signature(x = "HikeR", y = "missing"),
    function (x, type = c("series", "score", "both", "zoo"),
              h = 0, b = x@k, phase = c("none", "pt", "bb"),
              main = NULL, sub = NULL,
              pt.peak = list(col = "darkgreen", pch = 19, cex = 0.8),
              pt.trough = list(col = "darkred", pch = 19, cex = 0.8),
              area.se = list(col = "lightgray"),
              area.pb = list(col = "seagreen", density = 20),
              area.tb = list(col = "red2", density = 20),
              ...)\{
        type <- match.arg(type)
        phase <- match.arg(phase)
        N <- nrow(x@ys)
        xidx <- 1:N
        if ( is.null(sub) )\{
            sub <- paste("Score method: ", x@scoreby,
                         ", k = ", x@k, sep = "")
        \}
        if ( type == "score" )\{
            srange <- range(na.omit(x@ys[, 2]))
            if ( is.null(main) )\{
                main <- paste("Scores of time series:", x@yname)
            \}
            plot(c(1, N), srange, axes = FALSE,
                 main = main,
                 sub = sub,
                 xlab = "Time", ylab = "Score", type = "n")
            do.call(graphics::rect, c(list(xleft = 1,
                                           ybottom = srange[1],
                                           xright = x@k,
                                           ytop = srange[2]),
                                      area.se))
            do.call(graphics::rect, c(list(xleft = N - x@k + 1,
                                           ybottom = srange[1],
                                           xright = N,
                                           ytop = srange[2]),
                                      area.se))
            graphics::lines(coredata(x@ys[, 2]), type = "h", ...)
            graphics::abline(h = 0)
            graphics::abline(h = c(h, -h), col = "red")
            graphics::box()
            graphics::axis(1, at = xidx, labels = index(x@ys), tick = FALSE)
            idx <- pretty(srange)
            graphics::axis(2, at = idx, labels = idx)
        \}
        if ( type == "series" )\{
            yrange <- range(na.omit(x@ys[, 1]))
            if ( is.null(main) )\{
                if ( phase == "none" )\{
                    main <- paste("Peaks and Troughs of:", x@yname)
                \} else if ( phase == "pt" )\{
                    main <- paste("To-Peak and To-Trough Phases of:", x@yname)
                \}
                else if ( phase == "bb") \{
                    main <- paste("Burst and Bust Phases of:", x@yname)
                \}
            \}
            plot(c(1, N), yrange, axes = FALSE,
                 main = main, sub = sub,
                 xlab = "Time", ylab = "", type = "n")
            do.call(graphics::rect, c(list(xleft = 1,
                                           ybottom = yrange[1],
                                           xright = x@k,
                                           ytop = yrange[2]),
                                      area.se))
            do.call(graphics::rect, c(list(xleft = N - x@k + 1,
                                           ybottom = yrange[1],
                                           xright = N,
                                           ytop = yrange[2]),
                                      area.se))
            graphics::lines(coredata(x@ys[, 1]), ...)
            peakidx <- which(peaks(x, h = h)@pt == TRUE)
            ynum <- coredata(x@ys[index(x@ys)[peakidx], 1])
            do.call(graphics::points, c(list(y = ynum, x = peakidx),
                                        pt.peak))
            troughidx <- which(troughs(x, h = h)@pt == TRUE)
            ynum <- coredata(x@ys[index(x@ys)[troughidx], 1])
            do.call(graphics::points, c(list(y = ynum, x = troughidx),
                                        pt.trough))
            if ( phase  == "bb" )\{
                p <- phases(x, h = h, b = b)
                pchar <- as.character(coredata(p@pt))
                burstz <- new("PTBB",
                              pt = zoo(pchar == "burst",
                                       order.by = index(p@pt)),
                              type = "burst",
                              h = p@h)
                burstr <- runs(burstz)
                if ( !is.null(burstr) ) \{
                    xleft <- which(as.character(index(burstz@pt)) %in%
                                   as.character(burstr[, "From"]))
                    xright <- which(as.character(index(burstz@pt)) %in%
                                    as.character(burstr[, "To"]))
                    for (i in 1:length(xleft)) \{
                        do.call(graphics::rect, c(list(xleft = xleft[i],
                                                       ybottom = yrange[1],
                                                       xright = xright[i],
                                                       ytop = yrange[2]),
                                                  area.pb))
                    \}
                \}
                bustz <- new("PTBB",
                             pt = zoo(pchar == "bust",
                                      order.by = index(p@pt)),
                              type = "bust",
                             h = p@h)
                bustr <- runs(bustz)
                if ( !is.null(bustr) ) \{
                    xleft <- which(as.character(index(bustz@pt)) %in%
                                   as.character(bustr[, "From"]))
                    xright <- which(as.character(index(bustz@pt)) %in%
                                    as.character(bustr[, "To"]))
                    for (i in 1:length(xleft)) \{
                        do.call(graphics::rect, c(list(xleft = xleft[i],
                                                       ybottom = yrange[1],
                                                       xright = xright[i],
                                                       ytop = yrange[2]),
                                                  area.tb))
                    \}
                \}
            \}
            if ( phase == "pt" )\{
                top <- topeaks(x, h)
                topr <- runs(top)
                tot <- totroughs(x, h)
                totr <- runs(tot)
                if ( !is.null(topr) ) \{
                    xleft <- which(as.character(index(top@pt)) %in%
                                   as.character(topr[, "From"]))
                    xright <- which(as.character(index(top@pt)) %in%
                                    as.character(topr[, "To"]))
                    for (i in 1:length(xleft)) \{
                        do.call(graphics::rect, c(list(xleft = xleft[i],
                                                       ybottom = yrange[1],
                                                       xright = xright[i],
                                                       ytop = yrange[2]),
                                                  area.pb))
                    \}
                \}
                if ( !is.null(totr) ) \{
                    xleft <- which(as.character(index(tot@pt)) %in%
                                   as.character(totr[, "From"]))
                    xright <- which(as.character(index(tot@pt)) %in%
                                    as.character(totr[, "To"]))
                    for (i in 1:length(xleft)) \{
                        do.call(graphics::rect, c(list(xleft = xleft[i],
                                                       ybottom = yrange[1],
                                                       xright = xright[i],
                                                       ytop = yrange[2]),
                                                  area.tb))
                    \}
                \}
            \}
            graphics::box()
            graphics::axis(1, at = xidx, labels = index(x@ys),
                           tick = FALSE)
            idx <- pretty(yrange)
            graphics::axis(2, at = idx, labels = idx)
        \}
        if ( type == "both" )\{
            op <- graphics::par(no.readonly = TRUE)
            graphics::par(mfrow = c(2, 1))
            plot(x, type = "series", h = h, ...)
            plot(x, type = "score", h = h, ...)
            graphics::par(op)
        \}
        if ( type == "zoo" )\{
            plot(x@ys, ...)
        \}
    \}
)
\nwendcode{}\nwbegindocs{62}@

\subsection{\texttt{runs}-method for S4-class 'PTBB'}

\nwenddocs{}\nwbegincode{63}\sublabel{RNWhik1-Ptb33-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-Ptb33-1}}}\moddef{PtbbMethods.R~{\nwtagstyle{}\subpageref{RNWhik1-Ptb33-1}}}\endmoddef\let\nwnotused=\nwoutput{}
\LA{}man-PTBB-runs~{\nwtagstyle{}\subpageref{RNWhik1-man49-1}}\RA{}
setMethod("runs",
          signature(x = "PTBB"), function(x)\{
              if ( any(na.omit(x@pt)) )\{
                  p <- as.numeric(coredata(x@pt))
                  run <- rle(p)
                  peakruns <- which(run$values == 1)
                  cumidx <- cumsum(run$lengths)
                  n <- length(cumidx)
                  xidxright <- cumidx
                  xidxleft <- c(1, cumidx + 1)[-c(n + 1)]
                  xidx <- cbind(xidxleft, xidxright)
                  peakidx <- xidx[peakruns, ]
                  runscount <- nrow(xidx)
                  runsidx <- 1:runscount
                  ans <- sapply(runsidx, function(i)
                      x@pt[xidx[i, 1]:xidx[i, 2]])
                  pidx <- which(unlist(lapply(ans, function(r)
                      is.element(TRUE, r[1]))))
                  anstrue <- ans[pidx]
                  per <- lapply(anstrue, function(i)
                      data.frame(start(i), end(i)))
                  ans <- data.frame(do.call("rbind", per))
                  ans[, "Type"] <- x@type
                  colnames(ans) <- c("From", "To", "Type")
                  return(ans)
              \} else \{
                  return(NULL)
              \}
          \}
)
\nwnotused{PtbbMethods.R}\nwendcode{}\nwbegindocs{64}@


\section{Appendix}
\label{S4}

\subsection{Documentation of functions}
\label{S4SS1}

\nwenddocs{}\nwbegincode{65}\sublabel{RNWhik1-man34-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-man34-1}}}\moddef{man-func-score~{\nwtagstyle{}\subpageref{RNWhik1-man34-1}}}\endmoddef
#' Basic scoring methods for local minima and maxima
#'
#' These are basic functions for evaluating the centre
#' point of a time series as local minimum or maximum.
#' Hereby, a score value is computed according to various methods.
#' If the score is positive, the centre point is tentatively
#' classified as a local peak.
#' Incidentally, negative scores indicate a local minima.
#'
#' @param x \\code\{numeric\}, vector of length \\code\{2 * k + 1\}.
#' @param k \\code\{integer\}, the count of left/right neighbours.
#' @param scoreby \\code\{character\}, the scoring method to be used.
#' @param tval \\code\{numeric\}, factor for standard deviation band
#' if \\code\{scoreby = 'ttype'\}.
#' @param confby \\code\{integer\}, count of minimum vote,
#' values in the set \\code\{3:5\}.
#' @param ... ellipsis argument.
#'
#' @name score
#' @family scores
#' @return \\code\{numeric\}, the score value.
NULL

#' @rdname score
#' @export
\nwendcode{}\nwbegindocs{66}@

\nwenddocs{}\nwbegincode{67}\sublabel{RNWhik1-man35-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-man35-1}}}\moddef{man-func-hiker~{\nwtagstyle{}\subpageref{RNWhik1-man35-1}}}\endmoddef
#' Peak/trough scores of time series points
#'
#' This function computes the score value for each
#' data point of a time series. The first and last
#' \\code\{k\} observations are set to \\code\{NA\}.
#'
#' @inheritParams score
#' @param y \\code\{zoo\}, univariate time series.
#' @return An object of S4-class \\code\{HikeR\}.
#' @family scores
#'
#' @references Girish K. Palshikar. Simple Algorithms for
#' Peak Detection in Time-Series. In \\emph\{Proc. 1st Int. Conf.
#' Advanced Data Analysis,
#' Business Analytics and Intelligence\}, 2009.
#'
#' @examples
#' TEX <- SP500[, "TEX"]
#' ans <- hiker(TEX, k = 8, scoreby = "hybrid", tval = 0.1)
#' ans
#' plot(ans)
#'
#' @export
\nwendcode{}\nwbegindocs{68}@


\subsection{Documentation of S4-classes}
\label{S4SS2}

\nwenddocs{}\nwbegincode{69}\sublabel{RNWhik1-man36-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-man36-1}}}\moddef{man-class-HikeR~{\nwtagstyle{}\subpageref{RNWhik1-man36-1}}}\endmoddef
#' S4 class \\code\{HikeR\}
#'
#' Formal class for classifying local minima and maxima
#' of a time series.
#'
#' @slot ys \\code\{zoo\}, time series with associated scores.
#' @slot k \\code\{integer\}, count of left/right neigbours around centre point.
#' @slot scoreby \\code\{character\}, scoring method.
#' @slot yname \\code\{character\}, name of the series.
#' @exportClass HikeR
\nwendcode{}\nwbegindocs{70}@

\nwenddocs{}\nwbegincode{71}\sublabel{RNWhik1-man37-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-man37-1}}}\moddef{man-class-PTBB~{\nwtagstyle{}\subpageref{RNWhik1-man37-1}}}\endmoddef
#' S4 class \\code\{PTBB\}
#'
#' Formal class for peaks, troughs, burst, busts and
#' intermittent phase of a time series.
#'
#' @slot pt \\code\{zoo\}, logical: indicating peak/trough points.
#' @slot type \\code\{character\}, type of point/phase.
#' @slot h \\code\{numeric\}, the threshhold for score evaluation.
#' @exportClass PTBB
\nwendcode{}\nwbegindocs{72}@

\subsection{Documentation of S4-methods}
\label{S4SS3}

\nwenddocs{}\nwbegincode{73}\sublabel{RNWhik1-man38-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-man38-1}}}\moddef{man-HikeR-show~{\nwtagstyle{}\subpageref{RNWhik1-man38-1}}}\endmoddef
#' @rdname HikeR-class
#' @param object An object of S4 class \\code\{HikeR\}.
#' @export
\nwendcode{}\nwbegindocs{74}@

\nwenddocs{}\nwbegincode{75}\sublabel{RNWhik1-man39-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-man39-1}}}\moddef{man-HikeR-summary~{\nwtagstyle{}\subpageref{RNWhik1-man39-1}}}\endmoddef
#' @rdname HikeR-class
#' @aliases summary
#' @param ... Ellipsis argument.
#' @export
\nwendcode{}\nwbegindocs{76}@

\nwenddocs{}\nwbegincode{77}\sublabel{RNWhik1-man40-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-man40-1}}}\moddef{man-HikeR-peaks~{\nwtagstyle{}\subpageref{RNWhik1-man40-1}}}\endmoddef
#' @rdname HikeR-class
#' @aliases peaks
#' @param h \\code\{numeric\}, the threshold value for scores
#' to be considered as peaks/troughs.
#' @return Object of S4-class \\code\{PTBB\}.
#' @export
\nwendcode{}\nwbegindocs{78}@

\nwenddocs{}\nwbegincode{79}\sublabel{RNWhik1-man41-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-man41-1}}}\moddef{man-HikeR-troughs~{\nwtagstyle{}\subpageref{RNWhik1-man41-1}}}\endmoddef
#' @rdname HikeR-class
#' @aliases troughs
#' @export
\nwendcode{}\nwbegindocs{80}@

\nwenddocs{}\nwbegincode{81}\sublabel{RNWhik1-man42-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-man42-1}}}\moddef{man-HikeR-bursts~{\nwtagstyle{}\subpageref{RNWhik1-man42-1}}}\endmoddef
#' @rdname HikeR-class
#' @aliases bursts
#' @param b \\code\{integer\}, intermittent count of points between peaks.
#' @export
\nwendcode{}\nwbegindocs{82}@

\nwenddocs{}\nwbegincode{83}\sublabel{RNWhik1-man43-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-man43-1}}}\moddef{man-HikeR-busts~{\nwtagstyle{}\subpageref{RNWhik1-man43-1}}}\endmoddef
#' @rdname HikeR-class
#' @aliases busts
#' @export
\nwendcode{}\nwbegindocs{84}@

\nwenddocs{}\nwbegincode{85}\sublabel{RNWhik1-man44-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-man44-1}}}\moddef{man-HikeR-ridges~{\nwtagstyle{}\subpageref{RNWhik1-man44-1}}}\endmoddef
#' @rdname HikeR-class
#' @aliases ridges
#' @export
\nwendcode{}\nwbegindocs{86}@

\nwenddocs{}\nwbegincode{87}\sublabel{RNWhik1-man45-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-man45-1}}}\moddef{man-HikeR-phases~{\nwtagstyle{}\subpageref{RNWhik1-man45-1}}}\endmoddef
#' @rdname HikeR-class
#' @aliases phases
#' @export
\nwendcode{}\nwbegindocs{88}@

\nwenddocs{}\nwbegincode{89}\sublabel{RNWhik1-man46-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-man46-1}}}\moddef{man-HikeR-topeaks~{\nwtagstyle{}\subpageref{RNWhik1-man46-1}}}\endmoddef
#' @rdname HikeR-class
#' @aliases topeaks
#' @export
\nwendcode{}\nwbegindocs{90}@

\nwenddocs{}\nwbegincode{91}\sublabel{RNWhik1-man47-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-man47-1}}}\moddef{man-HikeR-totroughs~{\nwtagstyle{}\subpageref{RNWhik1-man47-1}}}\endmoddef
#' @rdname HikeR-class
#' @aliases totroughs
#' @export
\nwendcode{}\nwbegindocs{92}@

\nwenddocs{}\nwbegincode{93}\sublabel{RNWhik1-man48-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-man48-1}}}\moddef{man-HikeR-plot~{\nwtagstyle{}\subpageref{RNWhik1-man48-1}}}\endmoddef
#' @rdname HikeR-class
#' @aliases plot
#' @param x An object of S4 class \\code\{HikeR\}.
#' @param type \\code\{character\}, whether series, scores or both should be plotted.
#' @param phase \\code\{character\}, whether burst/bust or topeak/totrough phases
#' should be drawn in series plot.
#' @param pt.peak \\code\{list\}, named elements are passed to \\code\{graphics::points()\}.
#' @param main \\code\{character\}, main title of plot.
#' @param sub \\code\{character\}, sub title of plot
#' @param pt.trough \\code\{list\}, named elements are passed to \\code\{graphics::points()\}.
#' @param area.se \\code\{list\}, named elements are passed to \\code\{graphics::rect()\}
#' for areas of pre- and post sample points.
#' @param area.pb \\code\{list\}, named elements are passed to \\code\{graphics::rect()\}
#' for 'to-peak' or 'burst' phases.
#' @param area.tb \\code\{list\}, named elements are passed to \\code\{graphics::rect()\}
#' for 'to-trough' or 'bust' phases.
#' @export
\nwendcode{}\nwbegindocs{94}@

\nwenddocs{}\nwbegincode{95}\sublabel{RNWhik1-man49-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-man49-1}}}\moddef{man-PTBB-runs~{\nwtagstyle{}\subpageref{RNWhik1-man49-1}}}\endmoddef
#' @rdname PTBB-class
#' @aliases runs
#' @param x An object of S4 class \\code\{PTBB\}.
#' @export
\nwendcode{}\nwbegindocs{96}@

\subsection{Documentation of data set}

\nwenddocs{}\nwbegincode{97}\sublabel{RNWhik1-dat50-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-dat50-1}}}\moddef{data.R~{\nwtagstyle{}\subpageref{RNWhik1-dat50-1}}}\endmoddef\let\nwnotused=\nwoutput{}
#' Weekly price data of 476 S&P 500 constituents.
#'
#' The data set was used in the reference below. The authors adjusted
#' the price data for dividends and have removed stocks if two or
#' more consecutive missing values were found. In the remaining cases
#' the NA entries have been replaced by interpolated values.
#'
#'
#' @format A S3-class \\code\{zoo\} object with 265 weekly observations
#' of 476 members of the S&P 500 index. The sample starts at 2003-03-03
#' and ends in 2008-03-24.
#'
#' @references Cesarone, F. and Scozzari, A. and Tardella, F.: Portfolio
#'     selection problems in practice: a comparison between linear and
#'     quadratic optimization models, Working Paper, Universita degli
#'     Studi Roma Tre, Universita Telematica delle Scienze Umane and
#'     Universita di Roma, July 2010.
#'     \\url\{http://arxiv.org/ftp/arxiv/papers/1105/1105.3594.pdf\}
#'
#' @source \\url\{http://w3.uniroma1.it/Tardella/datasets.html\},\\cr
#' \\url\{ http://finance.yahoo.com/\}
"SP500"
\nwnotused{data.R}\nwendcode{}
\nwixlogsorted{c}{{Allclasses.R}{RNWhik1-All16-1}{\nwixd{RNWhik1-All16-1}}}%
\nwixlogsorted{c}{{Allgenerics.R}{RNWhik1-All20-1}{\nwixd{RNWhik1-All20-1}}}%
\nwixlogsorted{c}{{data.R}{RNWhik1-dat50-1}{\nwixd{RNWhik1-dat50-1}}}%
\nwixlogsorted{c}{{DESCRIPTION.R}{RNWhik1-DES15-1}{\nwixd{RNWhik1-DES15-1}}}%
\nwixlogsorted{c}{{HikeR-bursts}{RNWhik1-Hik26-1}{\nwixd{RNWhik1-Hik26-1}\nwixu{RNWhik1-Hik21-1}}}%
\nwixlogsorted{c}{{HikeR-busts}{RNWhik1-Hik27-1}{\nwixd{RNWhik1-Hik27-1}\nwixu{RNWhik1-Hik21-1}}}%
\nwixlogsorted{c}{{hiker-check}{RNWhik1-hik12-1}{\nwixd{RNWhik1-hik12-1}\nwixu{RNWhik1-hik11-1}}}%
\nwixlogsorted{c}{{hiker-func}{RNWhik1-hik11-1}{\nwixd{RNWhik1-hik11-1}\nwixu{RNWhik1-hik14-1}}}%
\nwixlogsorted{c}{{hiker-output}{RNWhik1-hik13-1}{\nwixd{RNWhik1-hik13-1}\nwixu{RNWhik1-hik11-1}}}%
\nwixlogsorted{c}{{HikeR-peaks}{RNWhik1-Hik24-1}{\nwixd{RNWhik1-Hik24-1}\nwixu{RNWhik1-Hik21-1}}}%
\nwixlogsorted{c}{{HikeR-phases}{RNWhik1-Hik29-1}{\nwixd{RNWhik1-Hik29-1}\nwixu{RNWhik1-Hik21-1}}}%
\nwixlogsorted{c}{{HikeR-plot}{RNWhik1-Hik32-1}{\nwixd{RNWhik1-Hik32-1}\nwixu{RNWhik1-Hik21-1}}}%
\nwixlogsorted{c}{{HikeR-ridges}{RNWhik1-Hik28-1}{\nwixd{RNWhik1-Hik28-1}\nwixu{RNWhik1-Hik21-1}}}%
\nwixlogsorted{c}{{HikeR-show}{RNWhik1-Hik22-1}{\nwixd{RNWhik1-Hik22-1}\nwixu{RNWhik1-Hik21-1}}}%
\nwixlogsorted{c}{{HikeR-summary}{RNWhik1-Hik23-1}{\nwixd{RNWhik1-Hik23-1}\nwixu{RNWhik1-Hik21-1}}}%
\nwixlogsorted{c}{{HikeR-topeaks}{RNWhik1-Hik30-1}{\nwixd{RNWhik1-Hik30-1}\nwixu{RNWhik1-Hik21-1}}}%
\nwixlogsorted{c}{{HikeR-totroughs}{RNWhik1-Hik31-1}{\nwixd{RNWhik1-Hik31-1}\nwixu{RNWhik1-Hik21-1}}}%
\nwixlogsorted{c}{{HikeR-troughs}{RNWhik1-Hik25-1}{\nwixd{RNWhik1-Hik25-1}\nwixu{RNWhik1-Hik21-1}}}%
\nwixlogsorted{c}{{hiker.R}{RNWhik1-hik14-1}{\nwixd{RNWhik1-hik14-1}}}%
\nwixlogsorted{c}{{HikerClass}{RNWhik1-Hik18-1}{\nwixd{RNWhik1-Hik18-1}\nwixu{RNWhik1-All16-1}}}%
\nwixlogsorted{c}{{HikerMethods.R}{RNWhik1-Hik21-1}{\nwixd{RNWhik1-Hik21-1}}}%
\nwixlogsorted{c}{{man-class-HikeR}{RNWhik1-man36-1}{\nwixd{RNWhik1-man36-1}\nwixu{RNWhik1-Hik18-1}}}%
\nwixlogsorted{c}{{man-class-PTBB}{RNWhik1-man37-1}{\nwixd{RNWhik1-man37-1}\nwixu{RNWhik1-Ptb19-1}}}%
\nwixlogsorted{c}{{man-func-hiker}{RNWhik1-man35-1}{\nwixd{RNWhik1-man35-1}\nwixu{RNWhik1-hik14-1}}}%
\nwixlogsorted{c}{{man-func-score}{RNWhik1-man34-1}{\nwixd{RNWhik1-man34-1}\nwixu{RNWhik1-sco10-1}}}%
\nwixlogsorted{c}{{man-HikeR-bursts}{RNWhik1-man42-1}{\nwixd{RNWhik1-man42-1}\nwixu{RNWhik1-Hik26-1}}}%
\nwixlogsorted{c}{{man-HikeR-busts}{RNWhik1-man43-1}{\nwixd{RNWhik1-man43-1}\nwixu{RNWhik1-Hik27-1}}}%
\nwixlogsorted{c}{{man-HikeR-peaks}{RNWhik1-man40-1}{\nwixd{RNWhik1-man40-1}\nwixu{RNWhik1-Hik24-1}}}%
\nwixlogsorted{c}{{man-HikeR-phases}{RNWhik1-man45-1}{\nwixd{RNWhik1-man45-1}\nwixu{RNWhik1-Hik29-1}}}%
\nwixlogsorted{c}{{man-HikeR-plot}{RNWhik1-man48-1}{\nwixd{RNWhik1-man48-1}\nwixu{RNWhik1-Hik32-1}}}%
\nwixlogsorted{c}{{man-HikeR-ridges}{RNWhik1-man44-1}{\nwixd{RNWhik1-man44-1}\nwixu{RNWhik1-Hik28-1}}}%
\nwixlogsorted{c}{{man-HikeR-show}{RNWhik1-man38-1}{\nwixd{RNWhik1-man38-1}\nwixu{RNWhik1-Hik22-1}}}%
\nwixlogsorted{c}{{man-HikeR-summary}{RNWhik1-man39-1}{\nwixd{RNWhik1-man39-1}\nwixu{RNWhik1-Hik23-1}}}%
\nwixlogsorted{c}{{man-HikeR-topeaks}{RNWhik1-man46-1}{\nwixd{RNWhik1-man46-1}\nwixu{RNWhik1-Hik30-1}}}%
\nwixlogsorted{c}{{man-HikeR-totroughs}{RNWhik1-man47-1}{\nwixd{RNWhik1-man47-1}\nwixu{RNWhik1-Hik31-1}}}%
\nwixlogsorted{c}{{man-HikeR-troughs}{RNWhik1-man41-1}{\nwixd{RNWhik1-man41-1}\nwixu{RNWhik1-Hik25-1}}}%
\nwixlogsorted{c}{{man-PTBB-runs}{RNWhik1-man49-1}{\nwixd{RNWhik1-man49-1}\nwixu{RNWhik1-Ptb33-1}}}%
\nwixlogsorted{c}{{NAMESPACE}{RNWhik1-NAM17-1}{\nwixd{RNWhik1-NAM17-1}\nwixu{RNWhik1-All16-1}}}%
\nwixlogsorted{c}{{PtbbClass}{RNWhik1-Ptb19-1}{\nwixd{RNWhik1-Ptb19-1}\nwixu{RNWhik1-All16-1}}}%
\nwixlogsorted{c}{{PtbbMethods.R}{RNWhik1-Ptb33-1}{\nwixd{RNWhik1-Ptb33-1}}}%
\nwixlogsorted{c}{{score-avgdiff}{RNWhik1-sco4-1}{\nwixd{RNWhik1-sco4-1}\nwixu{RNWhik1-sco10-1}}}%
\nwixlogsorted{c}{{score-diffmean}{RNWhik1-sco3-1}{\nwixd{RNWhik1-sco3-1}\nwixu{RNWhik1-sco10-1}}}%
\nwixlogsorted{c}{{score-entropy}{RNWhik1-sco5-1}{\nwixd{RNWhik1-sco5-1}\nwixu{RNWhik1-sco10-1}}}%
\nwixlogsorted{c}{{score-hybrid}{RNWhik1-sco7-1}{\nwixd{RNWhik1-sco7-1}\nwixu{RNWhik1-sco10-1}}}%
\nwixlogsorted{c}{{score-maxdiff}{RNWhik1-sco1-1}{\nwixd{RNWhik1-sco1-1}\nwixu{RNWhik1-sco10-1}}}%
\nwixlogsorted{c}{{score-ttype}{RNWhik1-sco6-1}{\nwixd{RNWhik1-sco6-1}\nwixu{RNWhik1-sco10-1}}}%
\nwixlogsorted{c}{{score-vote}{RNWhik1-sco8-1}{\nwixd{RNWhik1-sco8-1}\nwixu{RNWhik1-sco10-1}}}%
\nwixlogsorted{c}{{score-wrapper}{RNWhik1-sco9-1}{\nwixd{RNWhik1-sco9-1}\nwixu{RNWhik1-sco10-1}}}%
\nwixlogsorted{c}{{score.R}{RNWhik1-sco10-1}{\nwixd{RNWhik1-sco10-1}}}%
\nwixlogsorted{i}{{scavgdiff}{scavgdiff}}%
\nwixlogsorted{i}{{scdiffmean}{scdiffmean}}%
\nwixlogsorted{i}{{scentropy}{scentropy}}%
\nwixlogsorted{i}{{schybrid}{schybrid}}%
\nwixlogsorted{i}{{scmaxdiff}{scmaxdiff}}%
\nwixlogsorted{i}{{score}{score}}%
\nwixlogsorted{i}{{scttype}{scttype}}%
\nwixlogsorted{i}{{scvote}{scvote}}%
\nwbegindocs{98}@

\subsection{Makefile}
\label{smake}
\VerbatimInput{Makefile}

\newpage
\section{Chunk Index}
\nowebchunks

\newpage
\section{Identifier Index}
\nowebindex

\newpage
\bibliographystyle{chicago}
\bibliography{hiker}

\end{document}
\nwenddocs{}
