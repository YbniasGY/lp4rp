\documentclass[a4paper]{article}
\usepackage[hyperref]{xcolor}
\definecolor{darkblue}{rgb}{0, 0, .4}
\usepackage[colorlinks=true,linkcolor=darkblue]{hyperref}
\usepackage{amsmath}
\usepackage[round]{natbib}
\usepackage{noweb}
\noweboptions{english,longxref}

\begin{document}

\title{R Package Development by Means of \\
  Literate Programming \texttt{(noweb)}}
\author{Bernhard Pfaff}
\date{\today}

\maketitle

\section{Introduction}


\section{Detecting Peaks/Troughs}

\subsection{Notation}
A uniformly sampled time series $\mathbf{y} = \{y_1, \ldots, y_i,
\ldots, y_T\}$ with $T$ data points is considered. The detection of
peak/trough points is achieved by a function $S(i, y_i, T)$ that
returns for data point $y_i$ a score value.\footnote{It suffices to
  provide a score function for peaks only. Trough points can be
  detected by using the negative values of the series $\mathbf{y}$.}.
If this score value surpasses a user-provided threshhold value
$\theta$, /i.e/, $S(i, y_i, T) \ge \theta$ then the point is
considered as a local peak/trough.\par

Furthermore, in case local peak/trough points appear closely together
with respect to time (clustered), then these points can be classified
as a burst or bust, respectively.

\subsection{Algorithms}
In \citet{PAL2009} five different score functions $S$ have been
suggested. All have in commom, that a centred window of size $2*k +
1 $ around $y_i$ is considered. That is, for a positive integer $k$
the $k$ right neigbours $N^+(i,k, T) = \{y_{i+1}, \ldots, y_{i + k}\}$
and the $k$ left neighbours $N^-(i, k, T) = \{\{y_{i-k}, \ldots,
y_{i-1}\}$ are employed for assessing $y\_i$ as a local
peak/trough. The union of $N^-(i, k, T)$ and $N^+(i, k, T)$ is defined
as $N(i, k, T) = N^-(i, k, T) \mathord{\cdot} N^+(i, k, T)$ and if the
centre point is included as $N'(i, k, T) = N^-(i, k, T) \mathord{\cdot}
y_i \mathord{\cdot} N^+(i, k, T)$.\par

The first function, $S_1$, computes the score value as the average of
the maximum differences between $y_i$ with its left and right
neighbours. The function is defined as:

\begin{equation}
\label{S1}
S_1 =
  \frac{\max{(y_i - y_{i-1}, \ldots, y_i - y_{i-k})} + \max{(y_i -
  y_{i+1}, \ldots, y_i - y_{i+k})}}{2}
\end{equation}

The equation~\eqref{S1} can be casted in R as:

\nwfilename{hiker.Rnw}\nwbegincode{1}\sublabel{RNWhik1-sco1-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-sco1-1}}}\moddef{score-maxdiff~{\nwtagstyle{}\subpageref{RNWhik1-sco1-1}}}\endmoddef
scmaxdiff <- function(x, k)\{
    cp <- k + 1L
    lmax <- max(x[cp] - head(x, k))
    rmax <- max(x[cp] - tail(x, k))
    (lmax + rmax) / 2.0
\}
\nosublabel{RNWhik1-sco1-1-u4}\nwindexdefn{scmaxdiff}{scmaxdiff}{RNWhik1-sco1-1}\eatline
\nwidentdefs{\\{{scmaxdiff}{scmaxdiff}}}\nwendcode{}\nwbegindocs{2}%def scmaxdiff

Instead of using the maximum differences of $y_i$ with its $k$ left
and right neighbours as in~\eqref{S1}, an alternative is to compute
the mean differences and evaluate the average thereof:

\begin{equation}
\label{S2}
S_2 = \frac{\frac{(y_i - y_{i-1}, \ldots, y_i - y_{i-k})}{k} +
\frac{(y_i - y_{i+1}, \ldots, y_i - y_{i+k})}{k}}{2}
\end{equation}

This equation can be casted in R as:

\nwenddocs{}\nwbegincode{3}\sublabel{RNWhik1-sco3-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-sco3-1}}}\moddef{score-diffmean~{\nwtagstyle{}\subpageref{RNWhik1-sco3-1}}}\endmoddef
scdiffmean <- function(x, k)\{
    cp <- k + 1L
    ldmean <- x[cp] - mean(head(x, k))
    rdmean <- x[cp] - mean(tail(x, k))
    (ldmean + rdmean) / 2.0
\}
\nwindexdefn{scdiffmean}{scdiffmean}{RNWhik1-sco3-1}\eatline
\nwidentdefs{\\{{scdiffmean}{scdiffmean}}}\nwendcode{}\nwbegindocs{4}%def scdiffmean

Another variation of score computation that has been proposed by
\citet{PAL2009} is to consider the differences to the mean of the $k$
left and right neighbours, that is:

\begin{equation}
\label{S3}
S_3 = \frac{
(y_i - \frac{(y_{i-1}, \ldots, y_{i-k})}{k}) +
(y_i - \frac{(y_{i+1}, \ldots, y_{i+k})}{k})}{2}
\end{equation}

The equation~\eqref{S3} can be casted as R function \verb?scavgdiff?
for instance as follows:

\nwenddocs{}\nwbegincode{5}\sublabel{RNWhik1-sco4-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-sco4-1}}}\moddef{score-avgdiff~{\nwtagstyle{}\subpageref{RNWhik1-sco4-1}}}\endmoddef
scavgdiff <- function(x, k)\{
    cp <- k + 1L
    lmean <- mean(x[cp] - head(x, k))
    rmean <- mean(x[cp] - tail(x, k))
    (lmean + rmean) / 2.0
\}
\nwindexdefn{scavgdiff}{scavgdiff}{RNWhik1-sco4-1}\eatline
\nwidentdefs{\\{{scavgdiff}{scavgdiff}}}\nwendcode{}\nwbegindocs{6}%def scavgdiff

The fourth proposed score function differs from the previous three in
the sense that it does take explicitly the differences between $y_i$
and its neighbours explicitly into account, but tries to capture its
information content by means of relative entropy. The entropy of a
vector $A$ with elements $A = \{a_1, \ldots, a_m\}$ is given as:

\begin{equation}
H_w(A) = \sum_{i=1}^M \left(-p_w(a_i)\log(p_w(a_i))\right)
\end{equation}

where $p_w(a_i)$ is an estimate of the density value at $a_i$. The
score function is now based on computing the entropies of $H(N((k, i,
T))$ and $H(N'(k, i, T))$. Hereby, the densities can be determined by
means of a kernel density estimator. The score function is then
defined as the difference of the entropies:

\begin{equation}
\label{S4}
S_4 = H(N((k, i, T)) - H(N'((k, i, T))
\end{equation}

This concept is implemented in the function \verb?scentropy()?. The
empirical density is computed by calling \verb?density()?. The ellipsis
argument of \verb?scentropy()? is passed down to this function and hereby
allowing the user to employ other than the default arguments of
\verb?density()?.

\nwenddocs{}\nwbegincode{7}\sublabel{RNWhik1-sco5-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-sco5-1}}}\moddef{score-entropy~{\nwtagstyle{}\subpageref{RNWhik1-sco5-1}}}\endmoddef
scentropy <- function(x, k, ...)\{
    cp <- k + 1L
    dfull <- density(x, ...)$y
    hfull <- sum(-dfull * log(dfull))
    dexct <- density(x[-cp], ...)$y
    hexct <- sum(-dexct * log(dexct))
    hfull - hexct
\}
\nwindexdefn{scentropy}{scentropy}{RNWhik1-sco5-1}\eatline
\nwidentdefs{\\{{scentropy}{scentropy}}}\nwendcode{}\nwbegindocs{8}%def scentropy

Finally, a moment-based score function has been put forward in the
article by Palshikar. Hereby, the first and second moment of $N((k, i,
T))$ are computed and a t-type statistic can be computed as $(y_i - m)
/ s$. If this statistic surpasses a provided threshhold $h$, then the
data point is considered as a local peak/trough.

\begin{equation}
\label{S5}
S_5 =
\begin{cases}
1 & (y_i - m) / s \ge h \\
0 & \text{else}
\end{cases}
\end{equation}

This type of scoring algorithm is implemented as function
\verb?scttype()? below:

\nwenddocs{}\nwbegincode{9}\sublabel{RNWhik1-sco6-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-sco6-1}}}\moddef{score-ttype~{\nwtagstyle{}\subpageref{RNWhik1-sco6-1}}}\endmoddef
scttype <- function(x, k, tval)\{
    cp <- k + 1L
    m <- mean(x[-cp])
    s <- sd(x[-cp])
    tstat <- (x[cp] - m) / s
    if ( abs(tstat) < tval )\{
        tstat <- 0
    \}
    tstat
\}
\nwindexdefn{scttype}{scttype}{RNWhik1-sco6-1}\eatline
\nwidentdefs{\\{{scttype}{scttype}}}\nwendcode{}\nwbegindocs{10}%def scttype

\subsection{Combining score methods}

\nwenddocs{}\nwbegincode{11}\sublabel{RNWhik1-sco7-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-sco7-1}}}\moddef{score-wrapper~{\nwtagstyle{}\subpageref{RNWhik1-sco7-1}}}\endmoddef
score <- function(x, k,
                  scoreby = c("vote", "avg", "diff", "max", "ent",
                              "ttype", "hybrid"),
                  tval = 1.0, confby = 3, ...)\{
    scoreby <- match.arg(scoreby)
    ans <- switch(scoreby,
                  vote = scvote(x, k, tval, confby, ...),
                  avg = scavgdiff(x, k),
                  diff = scdiffmean(x, k),
                  max = scmaxdiff(x, k),
                  ent = scentropy(x, k, ...),
                  ttype = scttype(x, k, tval),
                  hybrid = schybrid(x, k, tval, ...)
                  )
    ans
\}
\nwindexdefn{score}{score}{RNWhik1-sco7-1}\eatline
\nwidentdefs{\\{{score}{score}}}\nwidentuses{\\{{scavgdiff}{scavgdiff}}\\{{scdiffmean}{scdiffmean}}\\{{scentropy}{scentropy}}\\{{scmaxdiff}{scmaxdiff}}\\{{scttype}{scttype}}}\nwindexuse{scavgdiff}{scavgdiff}{RNWhik1-sco7-1}\nwindexuse{scdiffmean}{scdiffmean}{RNWhik1-sco7-1}\nwindexuse{scentropy}{scentropy}{RNWhik1-sco7-1}\nwindexuse{scmaxdiff}{scmaxdiff}{RNWhik1-sco7-1}\nwindexuse{scttype}{scttype}{RNWhik1-sco7-1}\nwendcode{}\nwbegindocs{12}%def score

\nwenddocs{}\nwbegincode{13}\sublabel{RNWhik1-sco8-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-sco8-1}}}\moddef{score-roxygen~{\nwtagstyle{}\subpageref{RNWhik1-sco8-1}}}\endmoddef
#' Basic scoring methods for local minima and maxima
#'
#' These are basic functions for evaluating the centre
#' point of a time series as local minimum or maximum.
#' Hereby, a score value is computed according to various methods.
#' If the score is positive, the centre point is tentatively
#' classified as a local peak.
#' Incidentally, negative scores indicate a local minima.
#'
#' @param x \\code\{numeric\}, vector of length \\code\{2 * k + 1\}.
#' @param k \\code\{integer\}, the count of left/right neighbours.
#' @param scoreby \\code\{character\}, the scoring method to be used.
#' @param tval \\code\{numeric\}, factor for standard deviation band
#' if \\code\{scoreby = 'ttype'\}.
#' @param confby \\code\{integer\}, count of minimum vote,
#' values in the set \\code\{3:5\}.
#' @param ... ellipsis argument.
#'
#' @name score
#' @family scores
#' @return \\code\{numeric\}, the score value.
NULL

#' @rdname score
#' @export
\nwendcode{}\nwbegindocs{14}@

The content/structure of the file \texttt{score.R} is given as:

\nwenddocs{}\nwbegincode{15}\sublabel{RNWhik1-sco9-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-sco9-1}}}\moddef{score.R~{\nwtagstyle{}\subpageref{RNWhik1-sco9-1}}}\endmoddef\let\nwnotused=\nwoutput{}
\LA{}score-roxygen~{\nwtagstyle{}\subpageref{RNWhik1-sco8-1}}\RA{}
\LA{}score-wrapper~{\nwtagstyle{}\subpageref{RNWhik1-sco7-1}}\RA{}
#' @rdname score
\LA{}score-maxdiff~{\nwtagstyle{}\subpageref{RNWhik1-sco1-1}}\RA{}
#' @rdname score
\LA{}score-diffmean~{\nwtagstyle{}\subpageref{RNWhik1-sco3-1}}\RA{}
#' @rdname score
\LA{}score-avgdiff~{\nwtagstyle{}\subpageref{RNWhik1-sco4-1}}\RA{}
#' @rdname score
\LA{}score-entropy~{\nwtagstyle{}\subpageref{RNWhik1-sco5-1}}\RA{}
#' @rdname score
\LA{}score-ttype~{\nwtagstyle{}\subpageref{RNWhik1-sco6-1}}\RA{}
\nwnotused{score.R}\nwendcode{}\nwbegindocs{16}@

Within this file, all score-related methods and the wrapper-function
\texttt{score()} is included. The function definitions are
interspersed with the roxygen tags, which will be parsed to the
\texttt{Rd}-file \texttt{score.Rd}.


\section{Package structure}


\subsection{Preliminaries}

First, a skeleton of the package

\nwenddocs{}\nwbegincode{17}\sublabel{RNWhik1-DES10-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-DES10-1}}}\moddef{DESCRIPTION.R~{\nwtagstyle{}\subpageref{RNWhik1-DES10-1}}}\endmoddef\let\nwnotused=\nwoutput{}
Package: hiker
Title: Local Peak and Trough of a Time Series
Version: 0.0.0.9000
Authors@R: person("Bernhard", "Pfaff", email = "bernhard@pfaffikus.de",
                  role = c("aut", "cre"))
Description: Methods for detecting local peaks and troughs of a time series.
Depends: R (>= 3.3.1), zoo, methods
License: GPL-3
Encoding: UTF-8
LazyData: true
\nwnotused{DESCRIPTION.R}\nwendcode{}\nwbegindocs{18}@



\subsection{Import directives and S4-classes}

\nwenddocs{}\nwbegincode{19}\sublabel{RNWhik1-All11-1}\nwmargintag{{\nwtagstyle{}\subpageref{RNWhik1-All11-1}}}\moddef{Allclasses.R~{\nwtagstyle{}\subpageref{RNWhik1-All11-1}}}\endmoddef\let\nwnotused=\nwoutput{}
#' @import methods
NULL
#' @import zoo
NULL
#' @importFrom stats density sd na.omit start end smooth
NULL
#' @importFrom utils head tail
NULL

# Setting old (aka S3) classes
setOldClass("zoo")

#' S4 class \\code\{HikeR\}
#'
#' Formal class for classifying local minima and maxima
#' of a time series.
#'
#' @slot ys \\code\{zoo\}, time series with associated scores.
#' @slot k \\code\{integer\}, count of left/right neigbours around centre point.
#' @slot scoreby \\code\{character\}, scoring method.
#' @slot yname \\code\{character\}, name of the series.
#' @exportClass HikeR
setClass("HikeR", slots = list(ys = "zoo",
                               k = "integer",
                               scoreby = "character",
                               yname = "character"))


#' S4 class \\code\{PTBB\}
#'
#' Formal class for peaks, troughs, burst, busts and
#' intermittent phase of a time series.
#'
#' @slot pt \\code\{zoo\}, logical: indicating peak/trough points.
#' @slot type \\code\{character\}, type of point/phase.
#' @slot h \\code\{numeric\}, the threshhold for score evaluation.
#' @exportClass PTBB
setClass("PTBB", slots = list(pt = "zoo",
                              type = "character",
                              h = "numeric"))
\nwnotused{Allclasses.R}\nwendcode{}
\nwixlogsorted{c}{{Allclasses.R}{RNWhik1-All11-1}{\nwixd{RNWhik1-All11-1}}}%
\nwixlogsorted{c}{{DESCRIPTION.R}{RNWhik1-DES10-1}{\nwixd{RNWhik1-DES10-1}}}%
\nwixlogsorted{c}{{score-avgdiff}{RNWhik1-sco4-1}{\nwixd{RNWhik1-sco4-1}\nwixu{RNWhik1-sco9-1}}}%
\nwixlogsorted{c}{{score-diffmean}{RNWhik1-sco3-1}{\nwixd{RNWhik1-sco3-1}\nwixu{RNWhik1-sco9-1}}}%
\nwixlogsorted{c}{{score-entropy}{RNWhik1-sco5-1}{\nwixd{RNWhik1-sco5-1}\nwixu{RNWhik1-sco9-1}}}%
\nwixlogsorted{c}{{score-maxdiff}{RNWhik1-sco1-1}{\nwixd{RNWhik1-sco1-1}\nwixu{RNWhik1-sco9-1}}}%
\nwixlogsorted{c}{{score-roxygen}{RNWhik1-sco8-1}{\nwixd{RNWhik1-sco8-1}\nwixu{RNWhik1-sco9-1}}}%
\nwixlogsorted{c}{{score-ttype}{RNWhik1-sco6-1}{\nwixd{RNWhik1-sco6-1}\nwixu{RNWhik1-sco9-1}}}%
\nwixlogsorted{c}{{score-wrapper}{RNWhik1-sco7-1}{\nwixd{RNWhik1-sco7-1}\nwixu{RNWhik1-sco9-1}}}%
\nwixlogsorted{c}{{score.R}{RNWhik1-sco9-1}{\nwixd{RNWhik1-sco9-1}}}%
\nwixlogsorted{i}{{scavgdiff}{scavgdiff}}%
\nwixlogsorted{i}{{scdiffmean}{scdiffmean}}%
\nwixlogsorted{i}{{scentropy}{scentropy}}%
\nwixlogsorted{i}{{scmaxdiff}{scmaxdiff}}%
\nwixlogsorted{i}{{score}{score}}%
\nwixlogsorted{i}{{scttype}{scttype}}%
\nwbegindocs{20}@

\newpage
\section{Chunk Index}
\nowebchunks

\newpage
\section{Identifier Index}
\nowebindex

\newpage
\bibliographystyle{chicago}
\bibliography{hiker}

\end{document}
\nwenddocs{}
