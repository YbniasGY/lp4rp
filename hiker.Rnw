\documentclass[a4paper]{article}
\usepackage[hyperref]{xcolor}
\definecolor{darkblue}{rgb}{0, 0, .4}
\usepackage[colorlinks=true,linkcolor=darkblue]{hyperref}
\usepackage{amsmath}
\usepackage[round]{natbib}
\usepackage{graphicx}
\usepackage{noweb}
\noweboptions{english,longxref}
\usepackage{fancyvrb}
\RecustomVerbatimCommand{\VerbatimInput}{VerbatimInput}{frame=lines, fontsize=\footnotesize}
\newcommand{\pkg}[1]{{\fontseries{b}\selectfont #1}}


\begin{document}

\title{R Package Development by Means of \\
  Literate Programming \texttt{(noweb)}}
\author{Bernhard Pfaff}
\date{\today}

\maketitle

\section{Introduction}
\label{S1}

The topic of this article is to elucidate the creation of the R
package \pkg{hiker} by means of literate programming (henceforth:
LP). LP has been introduced by \citet{KNU1984}. Its constituent
characteristic is that the source code of a program as well as the
documentation thereof resides in the same file. To stay in the example
of the \pkg{hiker} package: within the file you are currently reading,
\emph{i.e.}, \texttt{hiker.Rnw}, the whole R source code of the
package as well as an explanation of it, is provided.\footnote{This
  file and the requirements for generating the R package \pkg{hiker}
  are made available on github as
  project \href{https://github.com/bpfaff/lp4rp}{lp4rp}.}
This file can then be processed by the facilities offered in the R package
\pkg{Rnoweb} \citep[see][]{IHA2013}. \pkg{Rnoweb} is a
reimplementation of the \texttt{noweb} software \citep[see][]{RAM1994}
written entirely in R. Creating the whole R package \pkg{hiker} by
mere processing (tangling of the R code) of this file, is however not
entirely true. Given that R packages must meet certain requirements
with respect to the directory structure and the documentation of the
provided functions, methods and classes, some additional tools become
necessary. With respect to setting up the package structure and
saving the produced R source files into the package's sub-directory
\texttt{/R}, a \texttt{Makefile} is employed (the content of this file
is provided in the appendix of this article, see section
\ref{smake}). The generation of the \texttt{man}-pages is accomplished
by utilizing the facilities provided in the \pkg{roxygen2} and
\pkg{devtools} packages \citep[see][respectively]{WIC2015,WIC2016}.\par

What is the package \pkg{hiker}(pronounce as `hike---R') about? Within
\pkg{hiker} the routines for detecting local peaks/troughs of a time
series as proposed by \citet{PAL2009} have been implemented. The
knowledge of these points and the time spans in between these local
maxima/minima can be utilized for analyzing the behavior of predictor
variables in up-/down markets of a financial time series, \emph{e.g.},
a stock price, for instance. Surely, these phases could in principal
be detected by mere eyeball-econometrics, but this approach becomes
burdensome if local peaks/troughs of many time series must be
determined. The package itself is purely written in R and S4-classes
and methods are employed.\par

In the remainder of this article, the proposed algorithms are
presented in the subsequent section. The package structure, the
defined S4-classes with the available methods are discussed in Section
\ref{S3}. In the Appendix of this paper the documentation of the
package in the \texttt{roxygen}-format is provided. This organization
has the advantage that the focus is shifted on the R code snippets
only and is not interspersed with the documentation of the classes and
methods and functions provided by the package.

\section{Detecting Peaks/Troughs}
\label{S2}

\subsection{Notation}
\label{S2SS1}

A uniformly sampled time series $\mathbf{y} = \{y_1, \ldots, y_i,
\ldots, y_T\}$ with $T$ data points is considered. The detection of
peak/trough points is achieved by a function $S(i, y_i, T)$ that
returns for data point $y_i$ a score value.\footnote{It suffices to
  provide a score function for peaks only. Trough points can be
  detected by using the negative values of the series $\mathbf{y}$.}.
If this score value surpasses a user-provided threshold value
$\theta$, \emph{i.e}, $S(i, y_i, T) \ge \theta$ then the point is
considered as a local peak/trough.\par

Furthermore, in case local peak/trough points appear closely together
with respect to time (clustered), then these points can be classified
as a burst or bust, respectively.

\subsection{Algorithms}
\label{S2SS2}

In \citet{PAL2009} five different score functions $S$ have been
suggested. All have in common, that a centered window of size $2*k +
1 $ around $y_i$ is considered. That is, for a positive integer $k$
the $k$ right neighbors $N^+(i,k, T) = \{y_{i+1}, \ldots, y_{i + k}\}$
and the $k$ left neighbors $N^-(i, k, T) = \{\{y_{i-k}, \ldots,
y_{i-1}\}$ are employed for assessing $y\_i$ as a local
peak/trough. The union of $N^-(i, k, T)$ and $N^+(i, k, T)$ is defined
as $N(i, k, T) = N^-(i, k, T) \mathord{\cdot} N^+(i, k, T)$ and if the
center point is included as $N'(i, k, T) = N^-(i, k, T) \mathord{\cdot}
y_i \mathord{\cdot} N^+(i, k, T)$.\par

The first function, $S_1$, computes the score value as the average of
the maximum differences between $y_i$ with its left and right
neighbors. The function is defined as:

\begin{equation}
\label{EQ1}
S_1 =
  \frac{\max{(y_i - y_{i-1}, \ldots, y_i - y_{i-k})} + \max{(y_i -
  y_{i+1}, \ldots, y_i - y_{i+k})}}{2}
\end{equation}

For a span of a time series $\mathbf{y}$ of length $2k + 1$, denoted
by \texttt{x}, the equation~\eqref{EQ1} can be casted in R as:

<<score-maxdiff>>=
scmaxdiff <- function(x, k){
    cp <- k + 1L
    lmax <- max(x[cp] - head(x, k))
    rmax <- max(x[cp] - tail(x, k))
    (lmax + rmax) / 2.0
}
@ %def scmaxdiff

Instead of using the maximum differences of $y_i$ with its $k$ left
and right neighbors as in~\eqref{EQ1}, an alternative is to compute
the mean differences and evaluate the average thereof:

\begin{equation}
\label{EQ2}
S_2 = \frac{\frac{(y_i - y_{i-1}, \ldots, y_i - y_{i-k})}{k} +
\frac{(y_i - y_{i+1}, \ldots, y_i - y_{i+k})}{k}}{2}
\end{equation}

This equation can be casted in R as:

<<score-diffmean>>=
scdiffmean <- function(x, k){
    cp <- k + 1L
    ldmean <- x[cp] - mean(head(x, k))
    rdmean <- x[cp] - mean(tail(x, k))
    (ldmean + rdmean) / 2.0
}
@ %def scdiffmean

Another variation of score computation that has been proposed by
\citet{PAL2009} is to consider the differences to the mean of the $k$
left and right neighbors, that is:

\begin{equation}
\label{EQ3}
S_3 = \frac{
(y_i - \frac{(y_{i-1}, \ldots, y_{i-k})}{k}) +
(y_i - \frac{(y_{i+1}, \ldots, y_{i+k})}{k})}{2}
\end{equation}

The equation~\eqref{EQ3} can be casted as R function [[scavgdiff()]]
for instance as follows:

<<score-avgdiff>>=
scavgdiff <- function(x, k){
    cp <- k + 1L
    lmean <- mean(x[cp] - head(x, k))
    rmean <- mean(x[cp] - tail(x, k))
    (lmean + rmean) / 2.0
}
@ %def scavgdiff

The fourth proposed score function differs from the previous three in
the sense that it does take the differences between $y_i$
and its neighbors explicitly into account, but tries to capture its
information content by means of relative entropy. The entropy of a
vector $A$ with elements $A = \{a_1, \ldots, a_m\}$ is given as:

\begin{equation}
H_w(A) = \sum_{i=1}^M \left(-p_w(a_i)\log(p_w(a_i))\right)
\end{equation}

where $p_w(a_i)$ is an estimate of the density value at $a_i$. The
score function is now based on computing the entropies of $H(N((k, i,
T))$ and $H(N'(k, i, T))$. Hereby, the densities can be determined by
means of a kernel density estimator. The score function is then
defined as the difference of the entropies:

\begin{equation}
\label{EQ4}
S_4 = H(N((k, i, T)) - H(N'((k, i, T))
\end{equation}

This concept is implemented in the function [[scentropy()]]. The
empirical density is computed by calling [[density()]]. The ellipsis
argument of [[scentropy()]] is passed down to this function and hereby
allowing the user to employ other than the default arguments of
[[density()]].

<<score-entropy>>=
scentropy <- function(x, k, ...){
    cp <- k + 1L
    dfull <- density(x, ...)$y
    hfull <- sum(-dfull * log(dfull))
    dexct <- density(x[-cp], ...)$y
    hexct <- sum(-dexct * log(dexct))
    hfull - hexct
}
@ %def scentropy

Finally, a moment-based score function has been put forward in the
article by Palshikar. Hereby, the first and second moment of $N((k, i,
T))$ are computed and a t-type statistic can be computed as $(y_i - m)
/ s$. If this statistic surpasses a provided threshold $h$, then the
data point is considered as a local peak/trough.

\begin{equation}
\label{EQ5}
S_5 =
\begin{cases}
1 & (y_i - m) / s \ge h \\
0 & \text{else}
\end{cases}
\end{equation}

This type of scoring algorithm is implemented as function
[[scttype()]] below:

<<score-ttype>>=
scttype <- function(x, k, tval){
    cp <- k + 1L
    m <- mean(x[-cp])
    s <- sd(x[-cp])
    tstat <- (x[cp] - m) / s
    if ( abs(tstat) < tval ){
        tstat <- 0
    }
    tstat
}
@ %def scttype

Incidentally, an ensemble forecast of these five algorithms can be
utilized for local peak/trough classification. Hereby, one could
either use a hybrid approach, whereby only those data points are
considered as peak/trough points, if all five methods coincide. This
concept is casted in the function [[schybrid()]]. Hereby, the signs of
all five scoring algorithm are tested for equality.

<<score-hybrid>>=
schybrid <- function(x, k, tval, ...){
    s <- c(sign(scmaxdiff(x, k)),
           sign(scavgdiff(x, k)),
           sign(scdiffmean(x, k)),
           sign(scentropy(x, k, ...)),
           sign(scttype(x, k, tval)))
    val <- unique(s)
    if ( length(val) < 2 ){
        return(s[1])
    } else {
        return(0)
    }
}
@ %def schybrid

It is also conceivable to base the classification on a majority
vote. For instance, if three out of the five algorithm classify a data
point as a local peak/trough, then this is taken as sufficient
evidence. This approach is defined in the function [[scvote()]] below.
The count of same `votes' is set by the argument \texttt{confby}. Its
default value is $3$, \emph{i.e.}, a simple majority. For
\texttt{confby = 5} the function would return the same classification
as [[schybrid()]] does.

<<score-vote>>=
scvote <- function(x, k, tval, confby = 3, ...){
    s <- c(sign(scmaxdiff(x, k)),
           sign(scavgdiff(x, k)),
           sign(scdiffmean(x, k)),
           sign(scentropy(x, k, ...)),
           sign(scttype(x, k, tval)))
    pos <- rep(1, 5)
    zer <- rep(0, 5)
    neg <- rep(-1, 5)
    spos <- sum(s == pos)
    szer <- sum(s == zer)
    sneg <- sum(s == neg)
    v <- c(spos, szer, sneg)
    idx <- which(v >= confby)
    vals <- c(1, 0, -1)
    if ( length(idx) > 0 ){
        return(vals[idx])
    } else {
        return(0)
    }
}
@ %def scvote

\subsection{Combining score methods}
\label{S2SS3}

What has been accomplished so far, are the function definitions of the
five proposed heuristics and combinations thereof with respect to a
sub-sample a time series of length $2k + 1$. These functions are
now combined into a single [[score()]] function as shown in the
subsequent R code chunk. The selection of the kind of score
computation is conducted by calling the [[switch()]] function.

<<score-wrapper>>=
score <- function(x, k,
                  scoreby = c("vote", "avg", "diff", "max", "ent",
                              "ttype", "hybrid"),
                  tval = 1.0, confby = 3, ...){
    scoreby <- match.arg(scoreby)
    ans <- switch(scoreby,
                  vote = scvote(x, k, tval, confby, ...),
                  avg = scavgdiff(x, k),
                  diff = scdiffmean(x, k),
                  max = scmaxdiff(x, k),
                  ent = scentropy(x, k, ...),
                  ttype = scttype(x, k, tval),
                  hybrid = schybrid(x, k, tval, ...)
                  )
    ans
}
@ %def score

The functions for computing scores are grouped together in the R file
[[score.R]] as shown in the next chunk. The function definitions are
interspersed with the roxygen tags, which will be parsed to the
[[Rd]]-file [[score.Rd]]. Incidentally, only code chunk with names
ending in [[.R]] are treated as files that should be tangled and saved
under the given code chunk's name.

<<score.R>>=
<<man-func-score>>
<<score-wrapper>>
#' @rdname score
<<score-maxdiff>>
#' @rdname score
<<score-diffmean>>
#' @rdname score
<<score-avgdiff>>
#' @rdname score
<<score-entropy>>
#' @rdname score
<<score-ttype>>
#' @rdname score
<<score-hybrid>>
#' @rdname score
<<score-vote>>
@

So far the wrapper function [[score()]] has been created, by which a single
point is assessed for being a local maximum or minimum. For analyzing
a whole time series for its local extrema, this routine can then be applied
to each data point and its left/right neighbors. This task is
accomplished with the function [[hiker()]] as defined next.

<<hiker-func>>=
hiker <- function(y, k,
                  scoreby = c("vote", "avg", "diff", "max", "ent",
                              "ttype", "hybrid"),
                  tval = 1.0, confby = 3, ...){
<<hiker-check>>
    ## rolling centered window for peak scores
    s <- rollapply(y, width = ms, FUN = score,
                   k = k, scoreby = scoreby, tval = tval, ...)
<<hiker-output>>
}
@

The arguments of the function are [[y]] for the time series object,
[[k]] for the count of left/right neighbors, and [[scoreby]] for the
selection of the scoring method. The arguments [[tval]] and [[confby]]
belong the scoring concepts `ttype' and `hybrid', respectively, and
the ellipsis argument is passed down to the call of [[scentropy()]]
for [[scoreby = 'ent']].\par

The function body consists of three parts. First, the provided
arguments are checked for their validity (as shown in the following
code chunk). The computation of the scores is accomplished with the
[[rollapply()]] function of the package \pkg{zoo}
\citep[see][]{ZEI2005}. Finally, the returned object is created.\par

<<hiker-check>>=
    y <- as.zoo(y)
    ## checking arguments
    k <- as.integer(abs(k))
    ms <- 2 * k + 1L
    if ( is.null(dim(y)) ){
        yname <- "series"
        n <- length(y)
        if ( n < ms ) {
            stop(paste("Sample size of 'y' is ", n,
                       " and k = ", k, ".\n", sep = ""))
            }
    } else {
        n <- nrow(y)
        yname <- colnames(y)[1]
        if ( n < ms ) {
            stop(paste("Sample size of 'y' is ", n,
                       " and k = ", k, ".\n", sep = ""))
        }
        if ( ncol(y) > 1 ) {
            stop("Provide univariate time series of S3-class 'zoo'.\n")
        }
    }
    if ( (confby < 3) || (confby > 5) ){
        stop("\nArgument 'confby' must be integer and in set {3, 4, 5}.\n")
    }
    scoreby <- match.arg(scoreby)
@

Within the check section of the function body, the object [[y]] is
first coerced to a [[zoo]] object and the count of neighbors is
coerced to a positive integer. Next, the size of the sub-sample for
computing the scores is assigned to the object [[ms]]. The remaining
part consists of checks whether the series is univariate and its
length is at least $2 \times k + 1$. Finally, the scoring method is
determined from the argument [[scoreby]] by means of the [[match.arg()]]
function.\par

In the final part of the function body of [[hiker()]], the returned
object is created as depicted in the subsequent R code chunk.

<<hiker-output>>=
    ## merging time series and scores
    ans <- merge(y, s)
    colnames(ans) <- c("Series", "Scores")
    des <- switch(scoreby,
                  vote = "majority vote",
                  avg = "average of averaged differences",
                  diff = "average of mean differences",
                  max = "average of maximum differences",
                  ent = "difference of entropies",
                  ttype = "t-type statistic",
                  hybrid = "hybrid")
    new("HikeR", ys = ans, k = k, scoreby = des, yname = yname)
@

First, the time series object [[y]] is merged with the series of the
computed scores and assigned to [[ans]]. Next the type of scoring
method is stored as character string to [[des]]. Finally, an object of
S4-class [[HikeR]] is created and returned. The definition of this
formal class is provided in section~\ref{S3SS2}.\par

Given that [[hiker()]] is the core function of the package, it will be
stored in its own [[hiker.R]] file, as commanded by the next chunk.

<<hiker.R>>=
<<man-func-hiker>>
<<hiker-func>>
@

\section{Package structure}
\label{S3}

\subsection{Preliminaries}
\label{S3SS1}

R packages must contain a [[DESCRIPTION]] and a [[NAMESPACE]]
file. Both reside in the package's root directory. As mentioned
earlier, only chunks with names ending in `[[.R]]' are saved to disk
by the tangling function of \pkg{Rnoweb}. Therefore, the content
of the description file is first, casted in the [[DESCRIPTION.R]]
file as shown below and is then moved by a directive in the
[[Makefile]] to the root directory of the package \pkg{hiker} without
the file's suffix.

<<DESCRIPTION.R>>=
Package: hiker
Title: Local Peak and Trough of a Time Series
Version: 0.1-0
Authors@R: person("Bernhard", "Pfaff", email = "bernhard@pfaffikus.de",
                  role = c("aut", "cre"))
Description: Methods for detecting local peaks and troughs of a time series.
Depends: R (>= 3.3.1), zoo, methods
License: GPL-3
Encoding: UTF-8
LazyData: true
@

With respect to the creation of the [[NAMESPACE]] file, matters are a
bit different. The import/export directives contained in this file can
be written as [[roxygen]] tags and the assembly of the tags and the
saving of the file under the package's root directory is conducted by
the [[document()]] function of \pkg{devtools}. Hence, it suffices to
include the tags in a named chunk with suffix `[[.R]]'. In the case
\pkg{hiker} the import directives are included in the R-file
[[Allclasses.R]]. As is indicated by the file name, the definitions of
the S4-classes will also reside in this file. The skeleton of this
this file is provided in the subsequent chunk.

<<Allclasses.R>>=
<<NAMESPACE>>
<<HikerClass>>
<<PtbbClass>>
@

The import directives for the required packages and functions are then
given as:

<<NAMESPACE>>=
#' @import methods
NULL
#' @import zoo
NULL
#' @importFrom graphics plot
NULL
#' @importFrom stats density sd na.omit start end smooth
NULL
#' @importFrom utils head tail
NULL

# Setting old (aka S3) classes
setOldClass("zoo")
@

\subsection{S4-classes and generics}
\label{S3SS2}

Two S4-classes are defined. The first, [[HikeR]], has been
mentioned briefly in the discussion of the core function
[[hiker()]]. The class consists of four slots, as shown in the
subsequent code chunk. Objects of the slot [[ys]] are of class [[zoo]]
and contain the time series and the score value. The slot [[k]] is of
type [[integer]] and holds the count of left/right neighbors. The
character slot [[scoreby]] provides a literal description of the
employed scoring algorithm and the slot [[yname]] is a character
string of the time series name.

<<HikerClass>>=
<<man-class-HikeR>>
setClass("HikeR", slots = list(ys = "zoo",
                               k = "integer",
                               scoreby = "character",
                               yname = "character"))
@

The [[HikeR]]-class does not contain explicitly the information
whether a certain data point is classified as a peak or trough, or
does belong to a certain phase of the time series progression. This
lack of explicit information is filled by the S4-class [[PTBB]]; it is
a short-hand for
`\underline{P}eaks\underline{T}roughs\underline{B}urst\underline{B}ust'. Its
slot [[pt]] is of informal class [[zoo]] and is a logical whether a
data point does belong to one the above mentioned points/phases. The
slot [[type]] is a literal description thereof and the employed
threshold value for making this classification is available in the
slot [[h]]. The class definition is provided in the subsequent code
chunk.

<<PtbbClass>>=
<<man-class-PTBB>>
setClass("PTBB", slots = list(pt = "zoo",
                              type = "character",
                              h = "numeric"))
@

Next, the following generic functions are defined in the file
[[Allgenerics.R]]. The methods of these generics are discussed in the
section \ref{S3SS3}.

<<Allgenerics.R>>=
# generic for extracting peaks
setGeneric("peaks", function(object, ...) standardGeneric("peaks"))
# generic for extracting troughs
setGeneric("troughs", function(object, ...) standardGeneric("troughs"))
# generic for extracting bursts
setGeneric("bursts", function(object, ...) standardGeneric("bursts"))
# generic for extracting busts
setGeneric("busts", function(object, ...) standardGeneric("busts"))
# generic for computing ridges
setGeneric("ridges", function(object, ...) standardGeneric("ridges"))
# generic for computing phases
setGeneric("phases", function(object, ...) standardGeneric("phases"))
# generic for extracting topeaks
setGeneric("topeaks", function(object, ...) standardGeneric("topeaks"))
# generic for extracting totroughs
setGeneric("totroughs", function(object, ...) standardGeneric("totroughs"))
# generic for computing runs
setGeneric("runs", function(x) standardGeneric("runs"))
@

\subsection{Methods for S4-class 'HikeR'}
\label{S3SS3}

In this section the S4-methods for objects of class [[HikeR]] are
discussed. The provided methods are for showing [[show()]],
summarizing [[summary()]], retrieval of peaks [[peaks()]] and troughs
[[troughs()]] for this type of objects. Furthermore, the concept of
bursts phases (close occurrence of peaks with respect to time) and
busts (close occurrence of troughs with respect to time) are defined
as methods [[bursts()]] and [[busts()]], respectively. Additional
methods for characterising the progression of a time series, such as
`ridges', `phases', `to-peaks' and `to-troughs' are provided,
too. Finally, a [[plot()]]-method is available whereby the user can
hightlight/shade the local optima and the phases in between them. All
of these methods are contained in the file [[hiker-methods.R]]. The
skeleton of this file is provided next.

<<HikerMethods.R>>=
<<HikeR-show>>
<<HikeR-summary>>
<<HikeR-peaks>>
<<HikeR-troughs>>
<<HikeR-bursts>>
<<HikeR-busts>>
<<HikeR-ridges>>
<<HikeR-phases>>
<<HikeR-topeaks>>
<<HikeR-totroughs>>
<<HikeR-plot>>
@

\subsubsection{\texttt{show}-method}
The [[show]]-method provides a brief overview of
[[HikeR]]-objects. Its definition is given in the following chunk. The
[[roxygen]] documentation is deferred to the chunk labeled
[[man-HikeR-show]] and provided in the appendix \ref{S5SS3}.

<<HikeR-show>>=
<<man-HikeR-show>>
setMethod("show",
          signature(object = "HikeR"), function(object){
              cat(paste("Peak/trough score computed as: ",
                        object@scoreby, ".\n", sep = ""))
              cat(paste("Count of left/right neighbours: ", object@k,
                        ".\n", sep = ""))
              cat("\nSummary statistics of scores:\n")
              print(summary(object))
          }
)
@

First, the employed scoring-method and the count of left/right
neighbors is printed \emph{via} the [[cat()]] and [[paste()]]
functions. Second, the [[summary]]-method is called, which provides
descriptive statistics of the scores and is formally defined in the
next section.

\subsubsection{\texttt{summary}-method}
The [[summary]]-method for numerics is applied to the second column of the
slot [[ys]], \emph{i.e.}, the computed score values. These numbers are
extracted from the [[zoo]] object by utilizing the [[coredata()]]
function. Akin, to the [[show]]-method, the within-package documentation
is deferred to the appendix.

<<HikeR-summary>>=
<<man-HikeR-summary>>
setMethod("summary",
          signature(object = "HikeR"),
          function (object, ...){
              summary(na.omit(coredata(object@ys[, 2])))
          }
)
@

\subsubsection{\texttt{peaks}-method}
The [[peaks]]-method is the first in a series of methods for
classifying the data points in a time series. This and the following
methods returns an object of formal class [[PTBB]]. Given that a peak
is defined as a score value greater than a threshold (the default is
[[h = 0]]), the core of the method is the logical statement in the
first line of the function's body, whether this is true. The remaining
slot entries of [[PTBB]] are set directly in the to [[new()]].

<<HikeR-peaks>>=
<<man-HikeR-peaks>>
setMethod("peaks",
    signature(object = "HikeR"),
    function (object, h = 0) {
        ans <- object@ys[, 2] > h
        new("PTBB", pt = ans, type = "peak", h = h)
    }
)
@

As before, the [[roxygen]] documention of this method is listed in the
appendix \ref{S5SS3}.

\subsubsection{\texttt{troughs}-method}
The mirror of peak detection is the trough classification. The
method's body is hence defined as the flip-side of the former method,
whereby the logical statement is casted now with respect to score
values that are less than the threshold value. The default for the
threshold is again set to [[h = 0]]. The computed logical array is now
of type `[[trough]]' and the object of class [[PTBB]] is returned in
the last line by invoking [[new()]].

<<HikeR-troughs>>=
<<man-HikeR-troughs>>
setMethod("troughs",
    signature(object = "HikeR"),
    function (object, h = 0) {
        ans <- object@ys[, 2] < h
        new("PTBB", pt = ans, type = "trough", h = h)
    }
)
@

\subsubsection{\texttt{bursts}-method}
Bursts are characterized by clusters of local peaks. Whether the
sequential occurrence of peaks do constitute a burst-phase, does depend
on the maximum allowed distance between two consecutive peak
points. This distance is depicted in the [[burst]]-method by the
argument [[b]] with a default value of [[k]], \emph{i.e.} the count of
considered left/right neighbors.

<<HikeR-bursts>>=
<<man-HikeR-bursts>>
setMethod("bursts",
    signature(object = "HikeR"),
    function (object, h = 0, b = object@k) {
        lpts <- object@ys[, 2] > h
        lidx <- which(lpts == TRUE)
        nidx <- length(lidx)
        if ( nidx > 1 ){
            for ( i in 2:nidx ){
                didx <- lidx[i] - lidx[i - 1]
                if ( didx <= b ){
                    lpts[(lidx[i]):(lidx[i - 1])] <- TRUE
                }
            }
        }
        ans <- zoo(lpts, order.by = index(object@ys))
        new("PTBB", pt = ans, type = "burst", h = h)
})
@

Within the definition of the method's body, first the peak points with
respect to a threshold [[h]] are determined and assigned to the
object [[lpts]]. Next, the index [[lidx]] of these occurrences is
created and its length is saved in the object [[nidx]]. This
information is then used in the following [[if]]-clause, to check
whether any local peak points are existent in the first place, a
necessary condition for the existence of burst phases. Within the
[[for]]-loop the distance between two consecutive index entries is
computed and compared to the bandwidth [[b]]. If the difference is
less or equal to [[b]], then the intermittent index entries are set to
[[TRUE]]. Finally, an object of S4-class [[PTBB]] is created that
holds as a logical the detected burst-phases.

\subsubsection{\texttt{busts}-method}
A bust episode is characterized by a concentration of trough points
with respect to time. As such, it is the flip-side of burst
phases. Hence, the skeleton and definition of the [[bust]]-method
differs only from the [[burst]]-method with respect to the detection
of local minimum values. Its definition is provided in the subsequent
code chunk.

<<HikeR-busts>>=
<<man-HikeR-busts>>
setMethod("busts",
    signature(object = "HikeR"),
    function (object, h = 0, b = object@k) {
        lpts <- object@ys[, 2] < h
        lidx <- which(lpts == TRUE)
        nidx <- length(lidx)
        if ( nidx > 1 ){
            for ( i in 2:nidx ){
                didx <- lidx[i] - lidx[i - 1]
                if ( didx <= b ){
                    lpts[(lidx[i]):(lidx[i - 1])] <- TRUE
                }
            }
        }
        ans <- zoo(lpts, order.by = index(object@ys))
        new("PTBB", pt = ans, type = "bust", h = h)
})
@

\subsubsection{\texttt{ridges}-method}
Data points of a time series can be classified as members of a
ridge-like progression, if they exclusively neither belong to a burst
or bust phase. This is given in a broader side-way movement. However,
it can be possible burst- and bust phases are interlaced with each
other (oscillating progression) and this case is also subsumed as a
ridge. The [[ridge]]-method defined below, employs the previously
discussed [[burst]] and [[bust]]-methods. The two logical arrays of
the burst (object [[burstp]]) and bust (object [[bustp]]) points are
then combined in the matrix [[bbp]]. The above stated rule is
implemented by computing the row sums thereof and checking whether this
is different from unity, in which case a data point is classified as
being a member of a ridge-phase (object [[ans]]). The method does
return an object of S4-class [[PTBB]] and the slot [[type]] is set to
`ridge'.

<<HikeR-ridges>>=
<<man-HikeR-ridges>>
setMethod("ridges",
    signature(object = "HikeR"),
    function (object, h = 0, b = object@k) {
        N <- nrow(object@ys)
        k <- object@k
        bustp <- busts(object, h = h, b = b)@pt
        burstp <- bursts(object, h = h, b = b)@pt
        bbp <- cbind(bustp, burstp)
        ans <- zoo(FALSE, order.by = index(bustp))
        ridx <- which ( (rowSums(bbp) > 1) | (rowSums(bbp) < 1) )
        ans[ridx] <- TRUE
        ans[1:object@k] <- NA
        ans[(N - k + 1):N] <- NA
        new("PTBB", pt = ans, type = "ridge", h = h)
})
@

\subsubsection{\texttt{phases}-method}
The [[phases]]-method encompasses the previous three methods and
classifies the phases of a time series into the categories `burst',
`bust' and `ridge'. The definition of this method is provided in the
subsequent code chunk. First, a numeric [[ans]] is defined with a
length equal to the size of the time series. Next, each of the three
methods are called and the detected busts, bursts and ridges are
assigned as character strings to the corresponding positions in
[[ans]]. Finally, the [[ans]] numeric is casted as an object of
informal class [[zoo]] and utilized in the creation of the [[PTBB]]
S4-class obejct.

<<HikeR-phases>>=
<<man-HikeR-phases>>
setMethod("phases",
    signature(object = "HikeR"),
    function (object, h = 0, b = object@k) {
        N <- nrow(object@ys)
        ans <- rep(NA, N)
        bustp <- busts(object, h = h, b = b)@pt
        ans[which(bustp == TRUE)] <- "bust"
        burstp <- bursts(object, h = h, b = b)@pt
        ans[which(burstp == TRUE)] <- "burst"
        ridgep <- ridges(object, h = h, b = b)@pt
        ans[which(ridgep == TRUE)] <- "ridge"
        ans <- factor(ans)
        ans <- zoo(ans, order.by = index(object@ys))
        new("PTBB", pt = ans, type = "phase", h = h)
})
@

\subsubsection{\texttt{topeaks}-method}
The [[topeaks]]-method can be utilized for detecting broader phases of
up-movements in a time series. These singled out episodes could then
be exploited for analysis the behavior of predictors in those
periods. The flip side of this method is the detection of `to-trough'
periods and can be utilized in a similar fashion (this method is
discussed in the next section).\par
The definition of the [[topeaks]]-method is shown below. First, a
[[zoo]]-object is assigned to [[ans]] and all entries are set to
[[TRUE]]. In the next two lines, the first and last $k$ entries of the
series are set to [[NA]], motivated by the fact that the first and
last left/right neighbors of a time series cannot be classified as a
peak. This fact is due to the symmetric filtering of the time series
for peaks. In the following lines the peak and trough points are
determined and the positions thereof are assigned to the objects
[[pidx]] and [[tidx]], respectively. The length of each object,
\emph{i.e.}, the count, is assigned to [[npidx]] for the peaks and
[[ntidx]] for the local trough points. Next sanity checks are
conducted. If neither peak nor trough points are existent, then the
method returns [[NULL]] with a corresponding warning.

<<HikeR-topeaks>>=
<<man-HikeR-topeaks>>
setMethod("topeaks",
    signature(object = "HikeR"),
    function (object, h = 0) {
        N <- nrow(object@ys)
        k <- object@k
        ans <- zoo(rep(TRUE, N), order.by = index(object@ys))
        ans[1:k] <- NA
        ans[(N - k + 1):N] <- NA
        peakp <- peaks(object, h)@pt
        pidx <- which(peakp == TRUE)
        npidx <- length(pidx)
        troup <- troughs(object, h)@pt
        tidx <- which(troup == TRUE)
        ntidx <- length(tidx)
        if ( npidx == 0 ){
            warning("\nNo local peak points.\n")
            return(NULL)
        }
        if ( ntidx == 0 ){
            warning("\nNo local trough points.\n")
            return(NULL)
        }
        ## if trough comes first, set prior points to FALSE
        if ( tidx[1] < pidx[1] ){
            ans[(k + 1):tidx[1]] <- FALSE
        }
        for ( i in 1:ntidx ) {
            previouspeaks <- which(pidx < tidx[i])
            countpreviouspeaks <- length(previouspeaks)
            if ( countpreviouspeaks > 0 ){
                maxpos <- which.max(object@ys[pidx[previouspeaks], 1])
                ans[(pidx[maxpos] + 1):tidx[i]] <- FALSE
                pidx <- pidx[-c(1:countpreviouspeaks)]
            }
        }
        new("PTBB", pt = ans, type = "topeak", h = h)
})
@

In the remaining part of the method's body, the `to-peaks' periods are
set. First, it is checked whether the first trough point occurs
earlier in time than a peak point. In this case, the entries of
[[ans]] until this trough point are set to [[FALSE]]. In the following
for-loop, the indices of the peaks that appeared earlier in a time
than a trough point are assigned to [[previouspeaks]]. If this vector
has length greater than zero, then the maximum index entry of the
peaks (the last one prior to the i-th trough point) is assigned to
[[maxpos]]. The entries in [[ans]] starting from the next period of
this last peak point until the i-th trough are then set to
[[FALSE]]. For house-keeping purposes the assessed peak-points in
[[pidx]] are then removed from this index and a new loop-iterations
commences. Finally, the method returns an [[PTBB]] S4-class object.

\subsubsection{\texttt{totroughs}-method}
For the detection of `to-trough' phases the method [[tottrough]] is
provided as shown below. Its definition is pretty straightforward,
given that the `to-trough' phases of a series are the complement of
the `to-peaks' periods. Having said this, the chest of this method is
first to utilize the previously discussed [[topeaks]] method and then
inverts the slot [[pt]] of the returned [[PTBB]] object.

<<HikeR-totroughs>>=
<<man-HikeR-totroughs>>
setMethod("totroughs",
    signature(object = "HikeR"),
    function (object, h = 0) {
        ans <- topeaks(object, h)
        ans@pt <- !ans@pt
        ans@type <- "tottrough"
        ans
})
@

\subsubsection{\texttt{plot}-method}
Finally, a [[plot]]-method is defined for objects of S4-class
[[HikeR]]. The skeleton is provided in the subsequent code
chunk. Given that quite a few methods for the detection of local
minima and maxima and the detection of certain phases have been
defined for this kind of objects, a visualization thereof becomes
necessary. The function's closure is endowed with arguments, such that
basically all information can be graphically represented. In
particular, the arguments [[type]] and [[phase]] are the two
work-horses for the creation of the relevant plots. The remaining
arguments can be utilized for custom adjustments with respect to the
labeling and coloring of the plots. Each of the plot-types are
discussed in the subsequent paragraphs.

<<HikeR-plot>>=
<<man-HikeR-plot>>
setMethod("plot",
    signature(x = "HikeR", y = "missing"),
    function (x, type = c("series", "score", "both", "zoo"),
              h = 0, b = x@k, phase = c("none", "pt", "bb"),
              main = NULL, sub = NULL,
              pt.peak = list(col = "darkgreen", pch = 19, cex = 0.8),
              pt.trough = list(col = "darkred", pch = 19, cex = 0.8),
              area.se = list(col = "lightgray"),
              area.pb = list(col = "seagreen", density = 20),
              area.tb = list(col = "red2", density = 20),
              ...){
        <<plotinit>>
        <<plotscore>>
        <<plotseries>>
        <<plotboth>>
        <<plotzoo>>
    }
)
@

In the first part of the method's body, the arguments are matched,
where applicable and the size of the time series is determined, as
well as the creation of an index (object [[xidx]]). Finally, a default
sub-title is defined by which the employed scoring method and the
count of left/right neighbors is set.

<<plotinit>>=
type <- match.arg(type)
phase <- match.arg(phase)
N <- nrow(x@ys)
xidx <- 1:N
if ( is.null(sub) ){
    sub <- paste("Score method: ", x@scoreby,
                 ", k = ", x@k, sep = "")
}
@

A bar chart of the scores is produced if [[type = 'score']] has been
chosen. The commands for creating this type of plot are shown in the
code chunk below. First, the range of the scores is determined,
followed by the creation of a default main title. Next, an empty plot
is created with limit margins according to the range of the score
values. Rectangular areas are superimposed on this device for the
first and last [[k]] data points, \emph{i.e.}, the count of neighbors.
Next, the score values are plotted as a bars ([[type = 'h']]). The
ellipsis argument is passed down to the [[graphics::lines()]]
function. A horizontal line for the threshold value is superimposed in
red. The drawing of a box and the labeling of the axis complete the
plot of the score values.

<<plotscore>>=
if ( type == "score" ){
    srange <- range(na.omit(x@ys[, 2]))
    if ( is.null(main) ){
        main <- paste("Scores of time series:", x@yname)
    }
    plot(c(1, N), srange, axes = FALSE,
         main = main,
         sub = sub,
         xlab = "Time", ylab = "Score", type = "n")
    do.call(graphics::rect, c(list(xleft = 1,
                                   ybottom = srange[1],
                                   xright = x@k,
                                   ytop = srange[2]),
                              area.se))
    do.call(graphics::rect, c(list(xleft = N - x@k + 1,
                                   ybottom = srange[1],
                                   xright = N,
                                   ytop = srange[2]),
                              area.se))
    graphics::lines(coredata(x@ys[, 2]), type = "h", ...)
    graphics::abline(h = h, col = "red")
    graphics::box()
    graphics::axis(1, at = xidx, labels = index(x@ys), tick = FALSE)
    idx <- pretty(srange)
    graphics::axis(2, at = idx, labels = idx)
}
@

The default plot-type is a series plot ([[type = 'series']]). The code
thereof is shown in the subsequent code chunk. First, the range of the
time series is determined and depending on the [[phase]] argument a
default title is created unless one is provided by the user. Akin to
the score plot, an empty plot device is created next with rectangular
areas at the start and end of the sample period. The appearance of
these is controlled by the list-type argument [[area.se]]. In the
following code section, the time series is plotted with the
[[lines()]] function from the graphics package and the peak/trough
points are then determined and superimposed on the time series chart
as points. The shape and color of these points can be adjusted by the
arguments [[pt.peak]] and [[pt.trough]], respectively.

<<plotseries>>=
if ( type == "series" ){
    yrange <- range(na.omit(x@ys[, 1]))
    if ( is.null(main) ){
        if ( phase == "none" ){
            main <- paste("Peaks and Troughs of:", x@yname)
        } else if ( phase == "pt" ){
            main <- paste("To-Peak and To-Trough Phases of:", x@yname)
        }
        else if ( phase == "bb") {
            main <- paste("Burst and Bust Phases of:", x@yname)
        }
    }
    plot(c(1, N), yrange, axes = FALSE,
         main = main, sub = sub,
         xlab = "Time", ylab = "", type = "n")
    do.call(graphics::rect, c(list(xleft = 1,
                                   ybottom = yrange[1],
                                   xright = x@k,
                                   ytop = yrange[2]),
                              area.se))
    do.call(graphics::rect, c(list(xleft = N - x@k + 1,
                                   ybottom = yrange[1],
                                   xright = N,
                                   ytop = yrange[2]),
                              area.se))
    graphics::lines(coredata(x@ys[, 1]), ...)
    peakidx <- which(peaks(x, h = h)@pt == TRUE)
    ynum <- coredata(x@ys[index(x@ys)[peakidx], 1])
    do.call(graphics::points, c(list(y = ynum, x = peakidx),
                                pt.peak))
    troughidx <- which(troughs(x, h = h)@pt == TRUE)
    ynum <- coredata(x@ys[index(x@ys)[troughidx], 1])
    do.call(graphics::points, c(list(y = ynum, x = troughidx),
                                pt.trough))
    <<plotbb>>
    <<plotpt>>
    graphics::box()
    graphics::axis(1, at = xidx, labels = index(x@ys),
                   tick = FALSE)
    idx <- pretty(yrange)
    graphics::axis(2, at = idx, labels = idx)
}
@

Depending on the value of the [[phase]] argument, either burst/bust or
to-peak/to-trough periods are overlaid on the figure. The code
thereof is presented in the next to two listings. Finally, a box is
drawn around the figure region and axis labeling is applied to the
graphic.

The burst and bust phases, if any, are first established by calling
the [[phases]] method. The slot [[pt]] of the assigned object [[p]] is
then investigated for entries equal to the character string
`burst' and a new object of S4-class [[PTBB]] is created. The start
and end points of these burst phases are determined by calling the
[[runs]]-method on this object. A description of the [[runs]]-method
is provided in the following section. If burst phases are existent,
then these are drawn as rectangles. Hereby, the user can alter the
appearance by the [[plot]] argument [[area.pb]]. In a similar manner,
the bust phases are localized and displayed on the figure.

<<plotbb>>=
if ( phase  == "bb" ){
    p <- phases(x, h = h, b = b)
    pchar <- as.character(coredata(p@pt))
    burstz <- new("PTBB",
                  pt = zoo(pchar == "burst",
                           order.by = index(p@pt)),
                  type = "burst",
                  h = p@h)
    burstr <- runs(burstz)
    if ( !is.null(burstr) ) {
        xleft <- which(as.character(index(burstz@pt)) %in%
                       as.character(burstr[, "From"]))
        xright <- which(as.character(index(burstz@pt)) %in%
                        as.character(burstr[, "To"]))
        for (i in 1:length(xleft)) {
            do.call(graphics::rect, c(list(xleft = xleft[i],
                                           ybottom = yrange[1],
                                           xright = xright[i],
                                           ytop = yrange[2]),
                                      area.pb))
        }
    }
    bustz <- new("PTBB",
                 pt = zoo(pchar == "bust",
                          order.by = index(p@pt)),
                 type = "bust",
                 h = p@h)
    bustr <- runs(bustz)
    if ( !is.null(bustr) ) {
        xleft <- which(as.character(index(bustz@pt)) %in%
                       as.character(bustr[, "From"]))
        xright <- which(as.character(index(bustz@pt)) %in%
                        as.character(bustr[, "To"]))
        for (i in 1:length(xleft)) {
            do.call(graphics::rect, c(list(xleft = xleft[i],
                                           ybottom = yrange[1],
                                           xright = xright[i],
                                           ytop = yrange[2]),
                                      area.tb))
        }
    }
}
@

Superimposing the `to-peaks' and `to-trough' phases is similar to the
shading of the burst/bust phases. The code chunk is shown
below. First, the method [[topeaks]] is invoked and the runs thereof
are assigned to the object [[topr]]. Similarly, the ranges of the
`to-trough' periods are established and assigned to the object
[[totr]]. Within the if-clauses the start and end point for each of the
to-peaks and to-trough periods are stored to the objects [[xleft]] and
[[xright]] and the regions are then plotted on top of the figure.

<<plotpt>>=
if ( phase == "pt" ){
    top <- topeaks(x, h)
    topr <- runs(top)
    tot <- totroughs(x, h)
    totr <- runs(tot)
    if ( !is.null(topr) ) {
        xleft <- which(as.character(index(top@pt)) %in%
                       as.character(topr[, "From"]))
        xright <- which(as.character(index(top@pt)) %in%
                        as.character(topr[, "To"]))
        for (i in 1:length(xleft)) {
            do.call(graphics::rect, c(list(xleft = xleft[i],
                                           ybottom = yrange[1],
                                           xright = xright[i],
                                           ytop = yrange[2]),
                                      area.pb))
        }
    }
    if ( !is.null(totr) ) {
        xleft <- which(as.character(index(tot@pt)) %in%
                       as.character(totr[, "From"]))
        xright <- which(as.character(index(tot@pt)) %in%
                        as.character(totr[, "To"]))
        for (i in 1:length(xleft)) {
            do.call(graphics::rect, c(list(xleft = xleft[i],
                                           ybottom = yrange[1],
                                           xright = xright[i],
                                           ytop = yrange[2]),
                                      area.tb))
        }
    }
}
@

The third plot-type is stacked version of the series and the score
plot. This type is returned when [[type = 'both']] has been set. The
code snippet is shown below.

<<plotboth>>=
if ( type == "both" ){
    op <- graphics::par(no.readonly = TRUE)
    graphics::par(mfrow = c(2, 1))
    plot(x, type = "series", h = h, ...)
    plot(x, type = "score", h = h, ...)
    graphics::par(op)
}
@

Finally, the series itself can be plotted by setting
[[type = 'zoo']]. Hereby, the [[plot]]-method of [[zoo]] objects is
employed. The ellipsis argument is passed down to the call of this
method, such that the user can make adjustments to the figure's
appearance.

<<plotzoo>>=
if ( type == "zoo" ){
    plot(x@ys, ...)
}
@


\subsection{\texttt{runs}-method for S4-class 'PTBB'}
As briefly mentioned in the previous section the [[runs]]-method
determines the ranges of consecutive [[TRUE]] values in the slot
[[pt]] of [[PTBB]] objects. Herby, the function [[rle()]] is
utilized. The returned array of this function contains the information
about runs as [['1']] values. These runs are assigned to the object
[[runs]]. In the following lines of the method's body, the left and
right points for each run are determined and a three-column data frame
is created that holds in the first two columns the start and end
periods of each run and the type of the [[PTBB]] object in its third.
Should no runs exist, then the method returns [[NULL]] with a
descriptive warning.

<<PtbbMethods.R>>=
<<man-PTBB-runs>>
setMethod("runs",
          signature(x = "PTBB"), function(x){
              if ( any(na.omit(x@pt)) ){
                  p <- as.numeric(coredata(x@pt))
                  run <- rle(p)
                  runs <- which(run$values == 1)
                  cumidx <- cumsum(run$lengths)
                  n <- length(cumidx)
                  xidxright <- cumidx
                  xidxleft <- c(1, cumidx + 1)[-c(n + 1)]
                  xidx <- cbind(xidxleft, xidxright)
                  idx <- xidx[runs, ]
                  runscount <- nrow(xidx)
                  runsidx <- 1:runscount
                  ans <- sapply(runsidx, function(i)
                      x@pt[xidx[i, 1]:xidx[i, 2]])
                  pidx <- which(unlist(lapply(ans, function(r)
                      is.element(TRUE, r[1]))))
                  anstrue <- ans[pidx]
                  per <- lapply(anstrue, function(i)
                      data.frame(start(i), end(i)))
                  ans <- data.frame(do.call("rbind", per))
                  ans[, "Type"] <- x@type
                  colnames(ans) <- c("From", "To", "Type")
                  return(ans)
              } else {
                  warning("No runs in PTBB-object detected.\n")
                  return(NULL)
              }
          }
)
@

\section{Example}
\label{S4}

In the following code chunk a brief example of detecting local peak
and trough point in the [[TEX]] stock is shown. After installation of
the package (running [[make install]]), one could load \pkg{hiker}
into the workspace. The stock price of [[TEX]] is contained in the
data set [[SP500]], which is part of \pkg{hiker}. This series can then
be used in the call to [[hiker()]]. Hereby, the count of neighbors
has been set to eight weeks and the hybrid algorithm is employed as
indicated by the [[soreby]] argument. The assigned object [[ans]] is
of S4-class [[HikeR]]. Next, a pdf-device is opened and in which the
plot of [[ans]] is saved. Whence the [[plot]]-method is called with
its default arguments, a time series chart with the detected local
peak and trough points is created. This figure is shown next, only if
[[make install]] has been conducted.

<<hikerEx.R>>=
library(hiker)
TEX <- SP500[, "TEX"]
ans <- hiker(TEX, k = 8, scoreby = "hybrid", tval = 0.1)
pdf("TEX-PekasTroughs.pdf", width = 6)
plot(ans)
dev.off()
@

A caveat of the [[noweb]] compared to the [[Sweave]] framework is that
one cannot directly execute R code in the chunks, but can only save
code to R files which can then be executed at a later stage. The
example [[hikerEx.R]] is no exception and this file is processed in
the [[install]] rule of the [[makefile]] after \pkg{hiker} has been
installed.

\IfFileExists{./TEX-PekasTroughs.pdf}{
\begin{center}
\begin{figure}
\includegraphics{TEX-PekasTroughs.pdf}
\end{figure}
\end{center}
}{}


\section{Appendix}
\label{S5}

\subsection{Documentation of functions}
\label{S5SS1}

<<man-func-score>>=
#' Basic scoring methods for local minima and maxima
#'
#' These are basic functions for evaluating the centre
#' point of a time series as local minimum or maximum.
#' Hereby, a score value is computed according to various methods.
#' If the score is positive, the centre point is tentatively
#' classified as a local peak.
#' Incidentally, negative scores indicate a local minima.
#'
#' @param x \code{numeric}, vector of length \code{2 * k + 1}.
#' @param k \code{integer}, the count of left/right neighbours.
#' @param scoreby \code{character}, the scoring method to be used.
#' @param tval \code{numeric}, factor for standard deviation band
#' if \code{scoreby = 'ttype'}.
#' @param confby \code{integer}, count of minimum vote,
#' values in the set \code{3:5}.
#' @param ... ellipsis argument.
#'
#' @name score
#' @family scores
#' @return \code{numeric}, the score value.
NULL

#' @rdname score
#' @export
@

<<man-func-hiker>>=
#' Peak/trough scores of time series points
#'
#' This function computes the score value for each
#' data point of a time series. The first and last
#' \code{k} observations are set to \code{NA}.
#'
#' @inheritParams score
#' @param y \code{zoo}, univariate time series.
#' @return An object of S4-class \code{HikeR}.
#' @family scores
#'
#' @references Girish K. Palshikar. Simple Algorithms for
#' Peak Detection in Time-Series. In \emph{Proc. 1st Int. Conf.
#' Advanced Data Analysis,
#' Business Analytics and Intelligence}, 2009.
#'
#' @examples
#' TEX <- SP500[, "TEX"]
#' ans <- hiker(TEX, k = 8, scoreby = "hybrid", tval = 0.1)
#' ans
#' plot(ans)
#'
#' @export
@


\subsection{Documentation of S4-classes}
\label{S5SS2}

<<man-class-HikeR>>=
#' S4 class \code{HikeR}
#'
#' Formal class for classifying local minima and maxima
#' of a time series.
#'
#' @slot ys \code{zoo}, time series with associated scores.
#' @slot k \code{integer}, count of left/right neigbours around centre point.
#' @slot scoreby \code{character}, scoring method.
#' @slot yname \code{character}, name of the series.
#' @exportClass HikeR
@

<<man-class-PTBB>>=
#' S4 class \code{PTBB}
#'
#' Formal class for peaks, troughs, burst, busts and
#' intermittent phase of a time series.
#'
#' @slot pt \code{zoo}, logical: indicating peak/trough points.
#' @slot type \code{character}, type of point/phase.
#' @slot h \code{numeric}, the threshhold for score evaluation.
#' @exportClass PTBB
@

\subsection{Documentation of S4-methods}
\label{S5SS3}

<<man-HikeR-show>>=
#' @rdname HikeR-class
#' @param object An object of S4 class \code{HikeR}.
#' @export
@

<<man-HikeR-summary>>=
#' @rdname HikeR-class
#' @aliases summary
#' @param ... Ellipsis argument.
#' @export
@

<<man-HikeR-peaks>>=
#' @rdname HikeR-class
#' @aliases peaks
#' @param h \code{numeric}, the threshold value for scores
#' to be considered as peaks/troughs.
#' @return Object of S4-class \code{PTBB}.
#' @export
@

<<man-HikeR-troughs>>=
#' @rdname HikeR-class
#' @aliases troughs
#' @export
@

<<man-HikeR-bursts>>=
#' @rdname HikeR-class
#' @aliases bursts
#' @param b \code{integer}, intermittent count of points between peaks.
#' @export
@

<<man-HikeR-busts>>=
#' @rdname HikeR-class
#' @aliases busts
#' @export
@

<<man-HikeR-ridges>>=
#' @rdname HikeR-class
#' @aliases ridges
#' @export
@

<<man-HikeR-phases>>=
#' @rdname HikeR-class
#' @aliases phases
#' @export
@

<<man-HikeR-topeaks>>=
#' @rdname HikeR-class
#' @aliases topeaks
#' @export
@

<<man-HikeR-totroughs>>=
#' @rdname HikeR-class
#' @aliases totroughs
#' @export
@

<<man-HikeR-plot>>=
#' @rdname HikeR-class
#' @aliases plot
#' @param x An object of S4 class \code{HikeR}.
#' @param type \code{character}, whether series, scores or both should be plotted.
#' @param phase \code{character}, whether burst/bust or topeak/totrough phases
#' should be drawn in series plot.
#' @param pt.peak \code{list}, named elements are passed to \code{graphics::points()}.
#' @param main \code{character}, main title of plot.
#' @param sub \code{character}, sub title of plot
#' @param pt.trough \code{list}, named elements are passed to \code{graphics::points()}.
#' @param area.se \code{list}, named elements are passed to \code{graphics::rect()}
#' for areas of pre- and post sample points.
#' @param area.pb \code{list}, named elements are passed to \code{graphics::rect()}
#' for 'to-peak' or 'burst' phases.
#' @param area.tb \code{list}, named elements are passed to \code{graphics::rect()}
#' for 'to-trough' or 'bust' phases.
#' @export
@

<<man-PTBB-runs>>=
#' @rdname PTBB-class
#' @aliases runs
#' @param x An object of S4 class \code{PTBB}.
#' @export
@

\subsection{Documentation of data set}

<<data.R>>=
#' Weekly price data of 476 S&P 500 constituents.
#'
#' The data set was used in the reference below. The authors adjusted
#' the price data for dividends and have removed stocks if two or
#' more consecutive missing values were found. In the remaining cases
#' the NA entries have been replaced by interpolated values.
#'
#'
#' @format A S3-class \code{zoo} object with 265 weekly observations
#' of 476 members of the S&P 500 index. The sample starts at 2003-03-03
#' and ends in 2008-03-24.
#'
#' @references Cesarone, F. and Scozzari, A. and Tardella, F.: Portfolio
#'     selection problems in practice: a comparison between linear and
#'     quadratic optimization models, Working Paper, Universita degli
#'     Studi Roma Tre, Universita Telematica delle Scienze Umane and
#'     Universita di Roma, July 2010.
#'     \url{http://arxiv.org/ftp/arxiv/papers/1105/1105.3594.pdf}
#'
#' @source \url{http://w3.uniroma1.it/Tardella/datasets.html},\cr
#' \url{ http://finance.yahoo.com/}
"SP500"
@

\subsection{Makefile}
\label{smake}
\VerbatimInput{Makefile}

\subsection{Literate programming file}
This pdf-file is itself installed within the package's sub-directory
[[./doc]]. For the user's ease of retrieving this document, the
function [[lpdoc()]] is defined as below:

<<lpdoc.R>>=
#' Displaying the literate programming document.
#'
#' This function can be used for opening the literate programming file with
#' the default pdf-viewer.
#' @export

lpdoc <- function(){
    p <- file.path(find.package("hiker"), "doc/hiker.pdf")
    system(paste("open ", p, sep = ""))
}
@



\newpage
\section{Chunk Index}
\nowebchunks

\newpage
\section{Identifier Index}
\nowebindex

\newpage
\bibliographystyle{chicago}
\bibliography{hiker}

\end{document}
